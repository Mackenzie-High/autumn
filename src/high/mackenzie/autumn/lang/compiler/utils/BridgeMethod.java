package high.mackenzie.autumn.lang.compiler.utils;

import com.google.common.collect.Lists;
import high.mackenzie.autumn.lang.compiler.compilers.ModuleCompiler;
import high.mackenzie.autumn.lang.compiler.typesystem.CustomDeclaredType;
import high.mackenzie.autumn.lang.compiler.typesystem.CustomMethod;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IFormalParameter;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IMethod;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IReferenceType;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IReturnType;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

/**
 * An instance of this method simplifies the compilation of a bridge method.
 *
 * @author Mackenzie High
 */
public final class BridgeMethod
{
    /**
     * This is the type-system representation of the actual method definition.
     */
    public final IMethod target;

    /**
     * This is the type-system representation of the bridge method definition.
     */
    public final CustomMethod bridge;

    /**
     * This is the return-type of the bridge definition.
     */
    public final IReturnType returns;

    /**
     * Sole Constructor.
     *
     * <p>
     * The bridge method definition will be added to the owner.
     * </p>
     *
     * @param owner is the owner of the bridge definition.
     * @param returns is the return-type of the bridge method definition.
     * @param target is the target method definition.
     */
    public BridgeMethod(final CustomDeclaredType owner,
                        final IReturnType returns,
                        final IMethod target)
    {
        this.target = target;
        this.returns = returns;

        /**
         * Create the type-system representation of the bridge method.
         */
        bridge = new CustomMethod(target.getOwner().getTypeFactory(), false);
        bridge.setAnnotations(target.getAnnotations());
        bridge.setModifiers(target.getModifiers());
        bridge.setName(target.getName());
        bridge.setOwner(owner);
        bridge.setParameters(target.getParameters());
        bridge.setReturnType(returns);
        bridge.setThrowsClause(target.getThrowsClause());

        /**
         * Add the bridge method to the owner.
         */
        final List<IMethod> methods = Lists.newLinkedList(owner.getMethods());
        methods.add(bridge);
        owner.setMethods(methods);
    }

    /**
     * This method creates the bytecode representation of the bridge method definition.
     *
     * @param module is the compiler of the enclosing module.
     * @return the generated bytecode.
     */
    public MethodNode compile(final ModuleCompiler module)
    {
        assert bridge.getReturnType().isReferenceType();

        final MethodNode method = Utils.bytecodeOf(module, bridge);

        // Remove the abstract and final modifiers.
        method.access = method.access & (~Opcodes.ACC_ABSTRACT);
        method.access = method.access & (~Opcodes.ACC_FINAL);

        // Add the bridge flag.
        method.access = method.access | Opcodes.ACC_BRIDGE;

        // Change the return-type.
        method.desc = bridge.getDescriptor();

        // Load 'this'
        method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 0));

        int address = 1;

        // Load the arguments.
        for (IFormalParameter param : bridge.getParameters())
        {
            method.instructions.add(Utils.selectLoadVarInsn(param.getType(), address));

            address += Utils.sizeof(param.getType());
        }

        // Invoke the non-bridge method.
        method.instructions.add(new MethodInsnNode(target.getOwner().isInterfaceType() ? Opcodes.INVOKEINTERFACE : Opcodes.INVOKEVIRTUAL,
                                                   Utils.internalName(target.getOwner()),
                                                   target.getName(),
                                                   target.getDescriptor()));

        // Cast the result produced by the non-bridge method to the appropriate type.
        method.instructions.add(new TypeInsnNode(Opcodes.CHECKCAST,
                                                 Utils.internalName((IReferenceType) bridge.getReturnType())));

        // Return the result.
        method.instructions.add(new InsnNode(Opcodes.ARETURN));

        return method;
    }
}
