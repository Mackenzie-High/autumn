/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package high.mackenzie.autumn.lang.compiler.compilers;

import autumn.lang.compiler.ClassFile;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IClassType;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IReturnType;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IType;
import high.mackenzie.autumn.lang.compiler.typesystem.design.IVariableType;
import high.mackenzie.autumn.lang.compiler.utils.Utils;
import java.util.List;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

/**
 * This class provides methods used to compile both lambdas and delegates.
 *
 * @author mackenzie
 */
public abstract class AbstractTypedFunctorCompiler
{
    /**
     * This method generates the method that performs the actual action of the functor.
     *
     * @return the bytecode method itself.
     */
    protected abstract MethodNode buildMethodInvoke2();

    /**
     * This method produces the supertype of the functor.
     *
     * @return the supertype of the functor.
     */
    protected abstract IClassType superType();

    /**
     * This method produces a list of the functor's formal-parameter types.
     *
     * @return the aforedescribed immutable list.
     */
    protected abstract List<IVariableType> parameterTypes();

    /**
     * This method produces the return-type of the functor.
     *
     * @return the return-type of the functor.
     */
    protected abstract IReturnType returnType();

    /**
     * This counter is used in the creation of a unique name for the functor.
     */
    private static int counter = 0;

    /**
     * This is the compiler of the module that contains the functor.
     */
    private ModuleCompiler module;

    /**
     * Sole Constructor.
     *
     * @param module is the compiler of the module that contains the functor.
     */
    public AbstractTypedFunctorCompiler(final ModuleCompiler module)
    {
        Preconditions.checkNotNull(module);

        this.module = module;

        counter++;
    }

    protected String name()
    {
        final String namespace = module.type.getNamespace().replace(".", "/") + '/';

        return namespace + "AutumnSyntheticFunctor" + counter;
    }

    public String descriptorOfInvoke2()
    {
        final StringBuilder descriptor = new StringBuilder();

        descriptor.append('(');

        for (IVariableType param : parameterTypes())
        {
            descriptor.append(param.getDescriptor());
        }

        descriptor.append(')');

        descriptor.append(returnType().getDescriptor());

        return descriptor.toString();
    }

    /**
     * This method generates the class-file representation of the functor.
     *
     * @return the generated bytecode class-file.
     */
    public ClassFile build()
    {
        final ClassNode klass = new ClassNode();
        klass.access = Opcodes.ACC_FINAL + Opcodes.ACC_SYNTHETIC;
        klass.name = name();
        klass.superName = Utils.internalName(superType());
        klass.fields = Lists.newLinkedList();
        klass.methods = Lists.newLinkedList();
        klass.version = Opcodes.V1_6;

        klass.methods.add(buildConstructor());
        klass.methods.add(buildMethodInvoke());
        klass.methods.add(buildMethodInvoke2());
        klass.methods.add(buildMethodReturnType());
        klass.methods.add(buildMethodParameterTypes());
        klass.methods.add(buildMethodParameterCount());

        final ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);

        klass.accept(writer);

        final byte[] bytecode = writer.toByteArray();

        final ClassFile result = new ClassFile(klass.name.replace("/", "."), bytecode);

        return result;
    }

    protected MethodNode buildConstructor()
    {
        final MethodNode method = new MethodNode();
        method.access = Opcodes.ACC_PUBLIC;
        method.name = "<init>";
        method.desc = "()V";
        method.exceptions = ImmutableList.of();

        String owner;
        String name;
        String desc;

        // Call super().
        method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 0)); // load 'this'
        owner = Utils.internalName(superType());
        name = "<init>";
        desc = "()V";
        method.instructions.add(new MethodInsnNode(Opcodes.INVOKESPECIAL, owner, name, desc));

        // Return.
        method.instructions.add(new InsnNode(Opcodes.RETURN));

        return method;
    }

    protected MethodNode buildMethodReturnType()
    {
        final MethodNode method = new MethodNode();
        method.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL;
        method.name = "returnType";
        method.desc = "()Ljava/lang/Class;";
        method.exceptions = ImmutableList.of();

        method.instructions.add(Utils.ldcClass(returnType()));
        method.instructions.add(new InsnNode(Opcodes.ARETURN));

        return method;
    }

    protected MethodNode buildMethodParameterTypes()
    {
        final MethodNode method = new MethodNode();
        method.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL;
        method.name = "parameterTypes";
        method.desc = "()I";
        method.exceptions = ImmutableList.of();

        method.instructions.add(new LdcInsnNode(parameterTypes().size()));
        method.instructions.add(new InsnNode(Opcodes.IRETURN));

        return method;
    }

    protected MethodNode buildMethodParameterCount()
    {
        final MethodNode method = new MethodNode();
        method.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL;
        method.name = "parameterCount";
        method.desc = "()I";
        method.exceptions = ImmutableList.of();

        method.instructions.add(new LdcInsnNode(parameterTypes().size()));
        method.instructions.add(new InsnNode(Opcodes.IRETURN));

        return method;
    }

    protected MethodNode buildMethodInvoke()
    {
        final IType ARG_STACK = module.program.typesystem.utils.ARGUMENT_STACK;

        final MethodNode method = new MethodNode();
        method.access = Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL;
        method.name = "invoke";
        method.desc = "(#1)V".replace("#1", ARG_STACK.getDescriptor());
        method.exceptions = ImmutableList.of("java/lang/Throwable");

        int index = 0;

        /**
         * Generate the bytecode instructions for the method.
         */
        final List<AbstractInsnNode> code = Lists.newLinkedList();
        {
            // Load the argument-stack onto the operand-stack.
            // This reference will be used later, when the result is pushed onto the argument-stack.
            code.add(new VarInsnNode(Opcodes.ALOAD, 1));

            // Load 'this' onto the operand-stack.
            // This reference will be used later, when the invoke2(*) method is invoked.
            code.add(new VarInsnNode(Opcodes.ALOAD, 0));

            // Transfer each parameter from the argument-stack onto the operand-stack.
            for (IVariableType param : parameterTypes())
            {
                // Load the argument-stack onto the operand-stack.
                // Address #0: 'this'
                // Address #1: argument-stack
                code.add(new VarInsnNode(Opcodes.ALOAD, 1));

                // Retrieve the argument.
                Utils.getArgument(module.program, code, param, index++);
            }

            // Invoke the invoke2(*) method.
            code.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,
                                        name(),
                                        "invoke2",
                                        descriptorOfInvoke2()));

            // Load the return-value onto the argument-stack.
            // If the invoke2(*) method returned void, load null.
            if (returnType().isVoidType())
            {
                code.add(new InsnNode(Opcodes.ACONST_NULL));

                Utils.pushArgument(module.program, code, module.program.typesystem.utils.OBJECT);
            }
            else
            {
                Utils.pushArgument(module.program, code, returnType());
            }

            // Return from the method
            code.add(new InsnNode(Opcodes.RETURN));
        }

        for (AbstractInsnNode node : code)
        {
            method.instructions.add(node);
        }

        return method;
    }
}
