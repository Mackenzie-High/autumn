<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RecordAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.utils</a> &gt; <span class="el_source">RecordAnalyzer.java</span></div><h1>RecordAnalyzer.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.utils;

import autumn.lang.Record;
import autumn.lang.internals.annotations.Getter;
import autumn.lang.internals.annotations.Setter;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.mackenziehigh.autumn.lang.compiler.typesystem.TypeFactory;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IDeclaredType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.ITypeFactory;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IVariableType;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * An instance of this class represents the basic bytecode representation of a record.
 *
 * @author Mackenzie High
 */
public final class RecordAnalyzer
{
    /**
     * This is the type of the record that is being compiled.
     */
    public final IDeclaredType type;

    /**
     * These are the elements in the new record.
     */
    public final Map&lt;String, RecordElement&gt; elements;

    /**
     * These are all the setter methods in the new record.
     */
<span class="fc" id="L40">    public final Set&lt;SetterMethod&gt; setters = Sets.newHashSet();</span>

    /**
     * These are the all getter methods in the record.
     */
<span class="fc" id="L45">    public final Set&lt;GetterMethod&gt; getters = Sets.newHashSet();</span>

    /**
     * These are the covariance violations detected in the record-type.
     */
    public final Set&lt;CovarianceViolation&gt; violations;

    /**
     * Sole Constructor.
     *
     * @param type is the type of the record that is being compiled.
     */
    public RecordAnalyzer(final IDeclaredType type)
<span class="fc" id="L58">    {</span>
<span class="fc" id="L59">        Preconditions.checkNotNull(type);</span>

<span class="fc" id="L61">        this.type = type;</span>

<span class="fc bfc" id="L63" title="All 2 branches covered.">        for (IMethod method : type.getAllVisibleMethods())</span>
        {
<span class="fc" id="L65">            potentiallyAddSetter(method);</span>
<span class="fc" id="L66">            potentiallyAddGetter(method);</span>
<span class="fc" id="L67">        }</span>

<span class="fc" id="L69">        this.violations = CovarianceViolationDetector.detect(this);</span>

<span class="fc" id="L71">        addBaseSetters();</span>
<span class="fc" id="L72">        addBaseGetters();</span>

<span class="fc" id="L74">        this.elements = elements();</span>
<span class="fc" id="L75">    }</span>

    /**
     * This method adds a setter method to the set of setters, if it is really a setter method.
     *
     * @param method is the method that may be a setter method.
     */
    private void potentiallyAddSetter(final IMethod method)
    {
        /**
         * A setter always takes exactly one argument.
         */
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (method.getParameters().size() != 1)</span>
        {
<span class="fc" id="L89">            return;</span>
        }

        /**
         * A setter has a special annotation applied to it.
         */
<span class="fc bfc" id="L95" title="All 2 branches covered.">        if (TypeSystemUtils.isAnnotationPresent(method, autumn.lang.internals.annotations.Setter.class) == false)</span>
        {
<span class="fc" id="L97">            return;</span>
        }

        /**
         * Create an object that represents the setter.
         */
<span class="fc" id="L103">        final IDeclaredType returns = (IDeclaredType) method.getReturnType();</span>
<span class="fc" id="L104">        final String name = method.getName();</span>
<span class="fc" id="L105">        final IVariableType value = (IVariableType) method.getParameters().get(0).getType();</span>
<span class="fc" id="L106">        final SetterMethod setter = new SetterMethod(method.getOwner(), returns, name, value);</span>

        /**
         * Remember the setter for later use.
         */
<span class="fc" id="L111">        setters.add(setter);</span>
<span class="fc" id="L112">    }</span>

    /**
     * This method adds a setter method to the set of getters, if it is really a getter method.
     *
     * @param method is the method that may be a getter method.
     */
    private void potentiallyAddGetter(final IMethod method)
    {
        /**
         * If the method takes parameters, then it is not a getter.
         */
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (method.getParameters().isEmpty() == false)</span>
        {
<span class="fc" id="L126">            return;</span>
        }

        /**
         * A getter has a special annotation applied to it.
         */
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (TypeSystemUtils.isAnnotationPresent(method, autumn.lang.internals.annotations.Getter.class) == false)</span>
        {
<span class="fc" id="L134">            return;</span>
        }

        /**
         * Create an object that represents the getter.
         */
<span class="fc" id="L140">        final String name = method.getName();</span>
<span class="fc" id="L141">        final IVariableType value = (IVariableType) method.getReturnType();</span>
<span class="fc" id="L142">        final GetterMethod getter = new GetterMethod(method.getOwner(), value, name);</span>

        /**
         * Remember the getter for later use.
         */
<span class="fc" id="L147">        getters.add(getter);</span>
<span class="fc" id="L148">    }</span>

    private void addBaseSetters()
    {
<span class="fc" id="L152">        final List&lt;SetterMethod&gt; initial = Lists.newArrayList(setters);</span>

<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (SetterMethod setter : initial)</span>
        {
<span class="fc" id="L156">            setters.add(new SetterMethod(type, type, setter.name, setter.parameter));</span>

<span class="fc" id="L158">            setters.add(new SetterMethod(type, setter.returns, setter.name, setter.parameter));</span>
<span class="fc" id="L159">        }</span>
<span class="fc" id="L160">    }</span>

    private void addBaseGetters()
    {
<span class="fc" id="L164">        final List&lt;GetterMethod&gt; initial = Lists.newArrayList(getters);</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (GetterMethod getter : initial)</span>
        {
<span class="fc" id="L168">            final GetterMethod method = new GetterMethod(type, getter.returns, getter.name);</span>

<span class="fc" id="L170">            getters.add(method);</span>
<span class="fc" id="L171">        }</span>
<span class="fc" id="L172">    }</span>

    /**
     * These are the setter methods that are needed in the record.
     *
     * @return an immutable set containing descriptions of the needed setters.
     */
    public Set&lt;SetterMethod&gt; setters()
    {
<span class="fc" id="L181">        final Set&lt;SetterMethod&gt; result = Sets.newHashSet();</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (SetterMethod setter : setters)</span>
        {
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (setter.owner.equals(type))</span>
            {
<span class="fc" id="L187">                result.add(setter);</span>
            }
<span class="fc" id="L189">        }</span>

<span class="fc" id="L191">        return Collections.unmodifiableSet(result);</span>
    }

    /**
     * These are the getter methods that are needed in the record.
     *
     * @return an immutable set containing descriptions of the needed getters.
     */
    public Set&lt;GetterMethod&gt; getters()
    {
<span class="fc" id="L201">        final Set&lt;GetterMethod&gt; result = Sets.newHashSet();</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (GetterMethod getter : getters)</span>
        {
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (getter.owner.equals(type))</span>
            {
<span class="fc" id="L207">                result.add(getter);</span>
            }
<span class="fc" id="L209">        }</span>

<span class="fc" id="L211">        return Collections.unmodifiableSet(result);</span>
    }

    /**
     * This method finds the names of the elements in the record-type.
     *
     * @return an immutable set containing the names of the elements in the record-type.
     */
    private Set&lt;String&gt; names()
    {
<span class="fc" id="L221">        final Set&lt;String&gt; names = Sets.newTreeSet();</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (GetterMethod getter : getters)</span>
        {
<span class="fc" id="L225">            names.add(getter.name);</span>
<span class="fc" id="L226">        }</span>

<span class="fc" id="L228">        return Collections.unmodifiableSet(names);</span>
    }

    /**
     * This method creates a map that maps the name of a element to a description of the element.
     *
     * @return the aforedescribed immutable map.
     */
    public Map&lt;String, RecordElement&gt; elements()
    {
<span class="fc" id="L238">        final Map&lt;String, RecordElement&gt; map = Maps.newTreeMap();</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (String name : names())</span>
        {
<span class="fc" id="L242">            map.put(name, new RecordElement(this, name));</span>
<span class="fc" id="L243">        }</span>

<span class="fc" id="L245">        return Collections.unmodifiableMap(map);</span>
    }

    public static interface Person
            extends Record
    {
        @Setter
        public Person name(Object name);

        @Getter
        public Object name();

        @Setter
        public Person age(int age);

        @Getter
        public int age();
    }

    public static interface Taxable
    {
        @Setter
        public Taxable name(String name);

        @Getter
        public String name();
    }

    public static interface Citizen
            extends Person,
                    Taxable
    {
        @Setter
        public Citizen name(String name);

        @Getter
        @Override
        public String name();

        @Setter
        public Citizen age(int age);

        @Getter
        @Override
        public int age();
    }

    public static interface M
    {
        @Setter
        public M x(final Object value);

        @Getter
        public Object x();
    }

<span class="nc" id="L301">    public static class S</span>
            implements M
    {
        @Setter
        public S x(final String value)
        {
<span class="nc" id="L307">            return null;</span>
        }

        @Setter
        @Override
        public S x(Object value)
        {
<span class="nc" id="L314">            throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
        }

        @Getter
        @Override
        public String x()
        {
<span class="nc" id="L321">            return null;</span>
        }
    }

    public static void main(final String[] args)
    {
<span class="nc" id="L327">        final ITypeFactory factory = new TypeFactory();</span>

<span class="nc" id="L329">        final IDeclaredType type = (IDeclaredType) factory.fromClass(S.class);</span>

<span class="nc" id="L331">        final RecordAnalyzer record = new RecordAnalyzer(type);</span>

<span class="nc" id="L333">        final Set&lt;String&gt; set = Sets.newTreeSet();</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">        for (SetterMethod setter : record.setters())</span>
        {
<span class="nc" id="L337">            set.add(setter.toString());</span>
<span class="nc" id="L338">        }</span>

<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (GetterMethod getter : record.getters())</span>
        {
<span class="nc" id="L342">            set.add(getter.toString());</span>
<span class="nc" id="L343">        }</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (String x : set)</span>
        {
<span class="nc" id="L347">            System.out.println(x);</span>
<span class="nc" id="L348">        }</span>

<span class="nc" id="L350">        System.out.println();</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">        for (CovarianceViolation violation : record.violations)</span>
        {
<span class="nc" id="L354">            System.out.println(violation);</span>
<span class="nc" id="L355">        }</span>
<span class="nc" id="L356">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>