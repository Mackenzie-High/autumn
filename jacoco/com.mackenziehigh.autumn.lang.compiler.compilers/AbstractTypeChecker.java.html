<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTypeChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.compilers</a> &gt; <span class="el_source">AbstractTypeChecker.java</span></div><h1>AbstractTypeChecker.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.compilers;

import autumn.lang.annotations.Infer;
import autumn.lang.compiler.ast.commons.IBinaryOperation;
import autumn.lang.compiler.ast.commons.IExpression;
import autumn.lang.compiler.ast.commons.IUnaryOperation;
import autumn.lang.compiler.ast.nodes.Name;
import autumn.lang.compiler.ast.nodes.TypeSpecifier;
import autumn.lang.compiler.ast.nodes.Variable;
import autumn.lang.internals.Operators;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IClassType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IDeclaredType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IExpressionType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IField;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IReturnType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IType;
import com.mackenziehigh.autumn.lang.compiler.utils.TypeSystemUtils;
import java.util.Collections;
import java.util.List;

/**
 * This class provides methods needed by all type-checkers.
 *
 * @author Mackenzie High
 */
abstract class AbstractTypeChecker
        extends AbstractAstVisitor
{
    /**
     * Essentially, this method retrieves the enclosing function.
     *
     * @return the enclosing function compiler.
     */
    public abstract AbstractFunctionCompiler function();

    /**
     * This is the compiler that is responsible for compiling the enclosing program.
     */
    protected final ProgramCompiler program;

    /**
     * This is the compiler that is responsible for compiling the enclosing module.
     */
    protected final ModuleCompiler module;

    /**
     * Sole Constructor.
     *
     * @param function is the compiler that is responsible for compiling the enclosing function.
     */
    protected AbstractTypeChecker(final AbstractFunctionCompiler function)
<span class="fc" id="L55">    {</span>
<span class="fc" id="L56">        Preconditions.checkNotNull(function);</span>

<span class="fc" id="L58">        this.program = function.module.program;</span>
<span class="fc" id="L59">        this.module = function.module;</span>
<span class="fc" id="L60">    }</span>

    /**
     * This method binds a type to an abstract-syntax-tree node.
     *
     * @param node is the AST node that is being typed.
     * @param type is the type of the construct represented by the AST node.
     */
    protected void infer(final IExpression node,
                         final IExpressionType type)
    {
<span class="fc" id="L71">        Preconditions.checkNotNull(node);</span>
<span class="fc" id="L72">        Preconditions.checkNotNull(type);</span>

<span class="fc" id="L74">        program.symbols.expressions.put(node, type);</span>
<span class="fc" id="L75">    }</span>

    /**
     * This method type-checks a condition expression.
     *
     * &lt;p&gt;
     * If the type-check fails, an error-report will be issued by the compiler.
     * &lt;/p&gt;
     *
     * @param expression is the expression that is a condition.
     */
    protected void condition(final IExpression expression)
    {
<span class="fc" id="L88">        Preconditions.checkNotNull(expression);</span>

<span class="fc" id="L90">        expression.accept(this);</span>

<span class="fc" id="L92">        program.checker.checkCondition(expression);</span>
<span class="fc" id="L93">    }</span>

    /**
     * This method requires that the type of an expression is a subtype of a given type.
     *
     * &lt;p&gt;
     * If the type-check fails, an error-report will be issued by the compiler.
     * &lt;/p&gt;
     *
     * @param expected is the expected type of the expression.
     * @param expression is the expression to type-check.
     */
    protected void assertType(final IReturnType expected,
                              final IExpression expression)
    {
<span class="nc" id="L108">        expression.accept(this);</span>

<span class="nc" id="L110">        program.checker.expectSubtype(expression, expected);</span>
<span class="nc" id="L111">    }</span>

    /**
     * This method generalizes the resolution and type-checking of a unary operator.
     *
     * &lt;p&gt;
     * If the type-checking fails, an error-report will be issued by the compiler.
     * &lt;/p&gt;
     *
     * @param operation is the unary operation itself.
     * @param function is the name of the static utility method that implements the operation.
     * @param operand is the only operand of the operation.
     */
    protected void unaryOperation(final IUnaryOperation operation,
                                  final String function,
                                  final IExpression operand)
    {
<span class="fc" id="L128">        Preconditions.checkNotNull(operation);</span>
<span class="fc" id="L129">        Preconditions.checkNotNull(function);</span>
<span class="fc" id="L130">        Preconditions.checkNotNull(operand);</span>

        // Perform type-checking on the left-operand.
<span class="fc" id="L133">        operand.accept(this);</span>
<span class="fc" id="L134">        final IExpressionType operand_type = program.symbols.expressions.get(operand);</span>

        // This is the type of the Operators class, which provides the operation implementations.
<span class="fc" id="L137">        final IDeclaredType owner = (IDeclaredType) program.typesystem</span>
<span class="fc" id="L138">                .typefactory()</span>
<span class="fc" id="L139">                .fromClass(Operators.class);</span>

        // Resolve the applicable overloads of the operator method.
<span class="fc" id="L142">        final List&lt;IMethod&gt; overloads = program.typesystem.utils.resolveStaticMethods(module.type,</span>
                                                                                      owner,
                                                                                      function,
<span class="fc" id="L145">                                                                                      Collections.&lt;IType&gt;singletonList(operand_type));</span>

        // If no applicable overload was found,
        // then issue an error-report,
        // because a bad operand was provided by the user.
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if (overloads.isEmpty())</span>
        {
            // This metohd will throw an exception.
<span class="nc" id="L153">            program.checker.reportNoSuchUnaryOperator(operation, operand_type);</span>
        }

        // The first method is the most specific.
<span class="fc" id="L157">        final IMethod overload = overloads.get(0);</span>

        // Remember the overload, because the code generator will need it later.
<span class="fc" id="L160">        program.symbols.calls.put(operation, overload);</span>

        // The return-type of the selected overload is the return-type of the expression.
<span class="fc" id="L163">        infer(operation, overload.getReturnType());</span>
<span class="fc" id="L164">    }</span>

    /**
     * This method generalizes the resolution and type-checking of a binary operator.
     *
     * &lt;p&gt;
     * If the type-checking fails, an error-report will be issued by the compiler.
     * &lt;/p&gt;
     *
     * @param operation is the binary operation itself.
     * @param function is the name of the static utility method that implements the operation.
     * @param operand is the only operand of the operation.
     */
    protected void binaryOperation(final IBinaryOperation operation,
                                   final String function,
                                   final IExpression left,
                                   final IExpression right)
    {
<span class="fc" id="L182">        Preconditions.checkNotNull(operation);</span>
<span class="fc" id="L183">        Preconditions.checkNotNull(function);</span>
<span class="fc" id="L184">        Preconditions.checkNotNull(left);</span>
<span class="fc" id="L185">        Preconditions.checkNotNull(right);</span>

        // These are the types of the operands.
<span class="fc" id="L188">        final List&lt;IType&gt; operands = Lists.newLinkedList();</span>

        // Perform type-checking on the left-operand.
<span class="fc" id="L191">        left.accept(this);</span>
<span class="fc" id="L192">        final IExpressionType left_type = program.symbols.expressions.get(left);</span>
<span class="fc" id="L193">        operands.add(left_type);</span>

        // Perform type-checking on the right-operand.
<span class="fc" id="L196">        right.accept(this);</span>
<span class="fc" id="L197">        final IExpressionType right_type = program.symbols.expressions.get(right);</span>
<span class="fc" id="L198">        operands.add(right_type);</span>

        // This is the type of the Operators class, which provides the operation implementations.
<span class="fc" id="L201">        final IDeclaredType owner = (IDeclaredType) program.typesystem</span>
<span class="fc" id="L202">                .typefactory()</span>
<span class="fc" id="L203">                .fromClass(Operators.class);</span>

        // Resolve the applicable overloads of the operator method.
<span class="fc" id="L206">        final List&lt;IMethod&gt; overloads = program.typesystem.utils.resolveStaticMethods(module.type,</span>
                                                                                      owner,
                                                                                      function,
                                                                                      operands);

        // If no applicable overload was found,
        // then issue an error-report,
        // because bad operands were provided by the user.
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (overloads.isEmpty())</span>
        {
            // This metohd will throw an exception.
<span class="nc" id="L217">            program.checker.reportNoSuchBinaryOperator(operation, left_type, right_type);</span>
        }

        // The first method is the most specific.
<span class="fc" id="L221">        final IMethod overload = overloads.get(0);</span>

        // Remember the overload, because the code generator will need it later.
<span class="fc" id="L224">        program.symbols.calls.put(operation, overload);</span>

        // The return-type of the selected overload is the return-type of the expression.
<span class="fc" id="L227">        infer(operation, overload.getReturnType());</span>
<span class="fc" id="L228">    }</span>

    /**
     * This method generalizes the resolution and type-checking of a static method invocation.
     *
     * @param operation is the invocation expression himself.
     * @param owner specifies the type that declares the invoked method.
     * @param name is the name of the invoked method.
     * @param arguments are the expressions that produce the invoked method's arguments.
     */
    protected void callStaticMethod(final IExpression operation,
                                    final TypeSpecifier owner,
                                    final Name name,
                                    final Iterable&lt;IExpression&gt; arguments)
    {
        /**
         * Type-check the owner.
         */
<span class="fc" id="L246">        final IDeclaredType owner_type = module.imports.resolveDeclaredType(owner);</span>

        /**
         * Visit and type-check the arguments.
         */
<span class="fc" id="L251">        final List&lt;IExpressionType&gt; args = Lists.newLinkedList();</span>

<span class="fc bfc" id="L253" title="All 2 branches covered.">        for (IExpression arg : arguments)</span>
        {
<span class="fc" id="L255">            arg.accept(this);</span>
<span class="fc" id="L256">            args.add(program.symbols.expressions.get(arg));</span>
<span class="fc" id="L257">        }</span>

        /**
         * Resolve the method overload.
         */
<span class="fc" id="L262">        final List&lt;IMethod&gt; methods = program.typesystem.utils.resolveStaticMethods(module.type,</span>
                                                                                    owner_type,
<span class="fc" id="L264">                                                                                    name.getName(),</span>
                                                                                    args);

        /**
         * If no method overload could be found, issue an error.
         */
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (methods.isEmpty())</span>
        {
<span class="nc" id="L272">            program.checker.reportNoSuchMethod(operation, true, owner_type, name.getName(), args);</span>
        }

        /**
         * Remember the resolved method overload, because the code-generator will need it.
         */
<span class="fc" id="L278">        final IMethod method = (IMethod) methods.get(0);</span>
<span class="fc" id="L279">        program.symbols.calls.put(operation, method);</span>

        /**
         * The return-type of a method-invocation is usually the return-type of the invoked method.
         * However, sometimes the return-type of the method-invocation is inferred.
         *
         * Note: We cannot infer the return-type when there are no arguments, even if requested.
         */
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (method.getParameters().isEmpty())</span>
        {
<span class="fc" id="L289">            infer(operation, method.getReturnType());</span>
        }
<span class="fc bfc" id="L291" title="All 2 branches covered.">        else if (TypeSystemUtils.isAnnotationPresent(method, Infer.class))</span>
        {
<span class="fc" id="L293">            infer(operation, args.get(0));</span>
        }
        else
        {
<span class="fc" id="L297">            infer(operation, method.getReturnType());</span>
        }
<span class="fc" id="L299">    }</span>

    /**
     * This method performs the resolution of a static-field.
     *
     * @param site is the site where the field is being used.
     * @param type is the type that contains the field.
     * @param name is the name of the field.
     * @return the field that was found, or null, if no field was found.
     */
    protected IField findStaticField(final IExpression site,
                                     final TypeSpecifier type,
                                     final String name)
    {
        /**
         * Get the type of the enclosing module in order to perform access checking.
         */
<span class="fc" id="L316">        final IClassType user = module.type;</span>

        /**
         * Get the type that owns the field.
         *
         * This will throw an exception, if the type does not exist
         * or type is not a declared-type.
         */
<span class="fc" id="L324">        final IDeclaredType owner = module.imports.resolveDeclaredType(type);</span>

        /**
         * Resolve the field.
         */
<span class="fc" id="L329">        final IField field = program.typesystem.utils.resolveStaticField(user,</span>
                                                                         owner,
                                                                         name);

        /**
         * If no field was found, then issue an error.
         */
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (field == null)</span>
        {
            // This will throw an exception.
<span class="nc" id="L339">            program.checker.reportNoSuchField(site, true, owner, name);</span>
        }

        /**
         * Remember the field that is being set, so that the code-generator can emit bytecode.
         */
<span class="fc" id="L345">        program.symbols.fields.put(site, field);</span>

<span class="fc" id="L347">        return field;</span>
    }

    /**
     * This method performs the resolution of an instance-field.
     *
     * @param site is the site where the field is being used.
     * @param object is the expression that produces the owner of the field.
     * @param name is the name of the field.
     * @return the field that was found, or null, if no field was found.
     */
    protected IField findField(final IExpression site,
                               final IExpression object,
                               final String name)
    {
        /**
         * Get the type of the enclosing module in order to perform access checking.
         */
<span class="fc" id="L365">        final IClassType user = module.type;</span>

        /**
         * Get the type that owns the field.
         */
<span class="fc" id="L370">        final IExpressionType owner_expr_type = program.symbols.expressions.get(object);</span>

        // This will throw an exception, if the owner-type is not a declared-type.
<span class="fc" id="L373">        program.checker.requireDeclaredType(object, owner_expr_type);</span>

        // This never fails.
<span class="fc" id="L376">        final IDeclaredType owner = (IDeclaredType) owner_expr_type;</span>

        /**
         * Resolve the field.
         */
<span class="fc" id="L381">        final IField field = program.typesystem.utils.resolveField(user,</span>
                                                                   owner,
                                                                   name);

        /**
         * If no field was found, then issue an error.
         */
<span class="fc bfc" id="L388" title="All 2 branches covered.">        if (field == null)</span>
        {
            // This will throw an exception.
<span class="nc" id="L391">            program.checker.reportNoSuchField(site, false, owner, name);</span>
        }

        /**
         * Remember the field that is being set, so that the code-generator can emit bytecode.
         */
<span class="fc" id="L397">        program.symbols.fields.put(site, field);</span>

<span class="fc" id="L399">        return field;</span>
    }

    /**
     * This method declares a local-variable and type-checks the declaration.
     *
     * @param variable is the variable to declare.
     * @param type is the type of the new variable.
     * @param mutable is false, iff the variable is readonly.
     */
    protected void declareVar(final Variable variable,
                              final IExpressionType type,
                              final boolean mutable)
    {
        /**
         * The variable cannot be declared, if another variable was already created
         * with the same name.
         */
<span class="fc" id="L417">        final boolean alread_declared = function().allocator.isDeclared(variable.getName());</span>
<span class="fc" id="L418">        program.checker.reportDuplicateVariable(variable, alread_declared);</span>

        /**
         * The type of a variable must be a variable-type.
         */
<span class="fc" id="L423">        program.checker.requireVariableType(variable, type);</span>

        /**
         * Perform the actual variable declaration.
         */
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (mutable)</span>
        {
<span class="fc" id="L430">            function().allocator.declareVar(variable.getName(), type);</span>
        }
        else
        {
<span class="fc" id="L434">            function().allocator.declareVal(variable.getName(), type);</span>
        }
<span class="fc" id="L436">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>