<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProgramCompiler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.compilers</a> &gt; <span class="el_source">ProgramCompiler.java</span></div><h1>ProgramCompiler.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.compilers;

import autumn.lang.compiler.ClassFile;
import autumn.lang.compiler.CompiledProgram;
import autumn.lang.compiler.ast.nodes.Module;
import autumn.lang.compiler.errors.IErrorReporter;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.mackenziehigh.autumn.lang.compiler.utils.Utils;
import java.util.List;

/**
 * An instance of this class controls the compilation of an entire program.
 *
 * @author Mackenzie High
 */
public final class ProgramCompiler
        implements ICompiler
{
    public final TypeSystem typesystem;

<span class="fc" id="L23">    public final SymbolTable symbols = new SymbolTable();</span>

    public final StaticChecker checker;

    public final IErrorReporter reporter;

    public final List&lt;Class&gt; imported;

<span class="fc" id="L31">    private final List&lt;ModuleCompiler&gt; modules = Lists.newLinkedList();</span>

    /**
     * Sole Constructor.
     *
     * @param reporter is used to report errors.
     * @param loader is the class-loader used to find previously loaded types.
     * @param imported are types to automatically import into every module.
     * @param mules are the modules that will be compiled.
     */
    private ProgramCompiler(final IErrorReporter reporter,
                            final ClassLoader loader,
                            final List&lt;Class&gt; imported,
                            final List&lt;Module&gt; mules)
<span class="fc" id="L45">    {</span>
<span class="fc" id="L46">        Preconditions.checkNotNull(reporter);</span>
<span class="fc" id="L47">        Preconditions.checkNotNull(mules);</span>

<span class="fc" id="L49">        this.reporter = reporter;</span>

<span class="fc" id="L51">        this.typesystem = new TypeSystem(loader);</span>

<span class="fc" id="L53">        this.checker = new StaticChecker(this);</span>

<span class="fc" id="L55">        this.imported = ImmutableList.copyOf(imported);</span>

        /**
         * Create a ModuleCompiler for each module AST node.
         */
<span class="fc bfc" id="L60" title="All 2 branches covered.">        for (Module m : mules)</span>
        {
<span class="fc bfc" id="L62" title="All 2 branches covered.">            if (ModuleCompiler.isEmpty(m) == false)</span>
            {
<span class="fc" id="L64">                this.modules.add(new ModuleCompiler(this, m));</span>
            }
<span class="fc" id="L66">        }</span>
<span class="fc" id="L67">    }</span>

    /**
     * This method generates the the compiled-program that can be written to a JAR file.
     *
     * @return a jar-able representation of the program.
     */
    private CompiledProgram build()
    {
        /**
         * The generated class-files will be added to this list.
         */
<span class="fc" id="L79">        final List&lt;ClassFile&gt; classes = Lists.newLinkedList();</span>

        /**
         * Add all the class-files, which represent modules, to the list.
         */
<span class="fc bfc" id="L84" title="All 2 branches covered.">        for (ModuleCompiler m : modules)</span>
        {
<span class="fc" id="L86">            classes.addAll(m.build());</span>
<span class="fc" id="L87">        }</span>

        /**
         * Add all the class-files, which represent lambdas, to the list.
         */
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (LambdaCompiler x : symbols.lambdas.values())</span>
        {
<span class="fc" id="L94">            classes.add(x.build());</span>
<span class="fc" id="L95">        }</span>

        /**
         * Find all of the entry-point functions, if any.
         */
<span class="fc" id="L100">        final List&lt;FunctionCompiler&gt; starts = this.findStart();</span>

        /**
         * There should only be one entry-point function.
         */
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        if (starts.size() &gt; 1)</span>
        {
<span class="nc" id="L107">            checker.reportTooManyStarts(starts.get(0).node);</span>
        }

        /**
         * Compute the name of the module that contains the entry-point function.
         */
<span class="fc bfc" id="L113" title="All 2 branches covered.">        final String main_class = starts.size() == 1</span>
<span class="fc" id="L114">                ? Utils.sourceName(starts.get(0).type.getOwner())</span>
<span class="fc" id="L115">                : null;</span>

        /**
         * Create an object representation of the compiled program.
         */
<span class="fc" id="L120">        final CompiledProgram result = new CompiledProgram(main_class, classes);</span>

<span class="fc" id="L122">        return result;</span>
    }

    /**
     * This method finds all the functions being compiled that are marked as the entry-point.
     *
     * &lt;p&gt;
     * If the returned list should not have more than one element,
     * because only one function can be the program's entry-point.
     * &lt;/p&gt;
     *
     * @return the functions that may be the program's entry-point.
     */
    private List&lt;FunctionCompiler&gt; findStart()
    {
<span class="fc" id="L137">        final List&lt;FunctionCompiler&gt; result = Lists.newLinkedList();</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (ModuleCompiler module : modules)</span>
        {
<span class="fc bfc" id="L141" title="All 2 branches covered.">            for (FunctionCompiler function : module.functions)</span>
            {
<span class="fc bfc" id="L143" title="All 2 branches covered.">                if (function.isAnnotationPresent(typesystem.utils.START))</span>
                {
<span class="fc" id="L145">                    result.add(function);</span>
                }
<span class="fc" id="L147">            }</span>
<span class="fc" id="L148">        }</span>

<span class="fc" id="L150">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeDeclaration()
    {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        for (ModuleCompiler m : modules)</span>
        {
<span class="fc" id="L161">            m.performTypeDeclaration();</span>
<span class="fc" id="L162">        }</span>
<span class="fc" id="L163">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeInitialization()
    {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (ModuleCompiler m : modules)</span>
        {
<span class="fc" id="L173">            m.performTypeInitialization();</span>
<span class="fc" id="L174">        }</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">        for (ExceptionCompiler ecmp : symbols.exceptions.values())</span>
        {
<span class="fc" id="L178">            ecmp.inferConstructors();</span>
<span class="fc" id="L179">        }</span>
<span class="fc" id="L180">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeStructureChecking()
    {
        /**
         * A compilation-unit can only contain a single start-function.
         */
<span class="fc" id="L191">        final List&lt;FunctionCompiler&gt; starts = this.findStart();</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (starts.size() &gt; 1)</span>
        {
<span class="nc" id="L195">            checker.reportTooManyStarts(starts.get(0).node);</span>
        }

        /**
         * Perform type-structure-checking on all the modules, etc.
         */
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (ModuleCompiler m : modules)</span>
        {
<span class="fc" id="L203">            m.performTypeStructureChecking();</span>
<span class="fc" id="L204">        }</span>
<span class="fc" id="L205">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeUsageChecking()
    {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (ModuleCompiler m : modules)</span>
        {
<span class="fc" id="L215">            m.performTypeUsageChecking();</span>
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">    }</span>

    /**
     * This method compiles a program to its bytecode representation.
     *
     * @param input are the modules in the program that will be compiled.
     * @param reporter is used to report errors.
     * @param loader is the class-loader used to find previously loaded types.
     * @param imported are types to automatically import into every module.
     * @return the bytecode representation of the compiled program; or null, if compilation fails.
     */
    public static CompiledProgram compile(final List&lt;Module&gt; input,
                                          final IErrorReporter reporter,
                                          final ClassLoader loader,
                                          final List&lt;Class&gt; imported)
    {

        try
        {
<span class="fc" id="L236">            final ProgramCompiler compiler = new ProgramCompiler(reporter, loader, imported, input);</span>

<span class="fc" id="L238">            compiler.performTypeDeclaration();</span>

<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (reporter.errorCount() &gt; 0)</span>
            {
<span class="nc" id="L242">                return null;</span>
            }

<span class="fc" id="L245">            compiler.performTypeInitialization();</span>

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">            if (reporter.errorCount() &gt; 0)</span>
            {
<span class="nc" id="L249">                return null;</span>
            }

<span class="fc" id="L252">            compiler.performTypeStructureChecking();</span>

<span class="pc bpc" id="L254" title="1 of 2 branches missed.">            if (reporter.errorCount() &gt; 0)</span>
            {
<span class="nc" id="L256">                return null;</span>
            }

<span class="fc" id="L259">            compiler.performTypeUsageChecking();</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (reporter.errorCount() &gt; 0)</span>
            {
<span class="fc" id="L263">                return null;</span>
            }

<span class="fc" id="L266">            final CompiledProgram program = compiler.build();</span>

<span class="fc" id="L268">            return program;</span>
        }
<span class="fc" id="L270">        catch (TypeCheckFailed ex)</span>
        {
            // Pass, because the error will be reported via the error-reporter object.
        }
<span class="nc" id="L274">        catch (Exception ex)</span>
        {
            // TODO: should a generalized exception handler go here, in case of compiler bugs?
<span class="nc" id="L277">            throw new RuntimeException(ex);</span>
<span class="fc" id="L278">        }</span>

<span class="fc" id="L280">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>