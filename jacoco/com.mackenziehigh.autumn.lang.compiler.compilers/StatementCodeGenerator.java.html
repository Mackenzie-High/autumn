<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StatementCodeGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.compilers</a> &gt; <span class="el_source">StatementCodeGenerator.java</span></div><h1>StatementCodeGenerator.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.compilers;

import autumn.lang.Delegate;
import autumn.lang.compiler.ast.commons.*;
import autumn.lang.compiler.ast.nodes.*;
import autumn.lang.internals.Helpers;
import autumn.util.F;
import com.google.common.collect.Lists;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IClassType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IDeclaredType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IType;
import com.mackenziehigh.autumn.lang.compiler.utils.Utils;
import java.util.List;
import java.util.Stack;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TryCatchBlockNode;
import org.objectweb.asm.tree.TypeInsnNode;

/**
 * An instance of this class can generate the bytecode that implements a statement.
 *
 * @author Mackenzie High
 */
<span class="fc" id="L31">final class StatementCodeGenerator</span>
        extends ExpressionCodeGenerator
{
    private final FunctionCompiler function;

<span class="fc" id="L36">    private final Stack&lt;LabelNode&gt; break_labels = new Stack&lt;LabelNode&gt;();</span>

<span class="fc" id="L38">    private final Stack&lt;LabelNode&gt; continue_labels = new Stack&lt;LabelNode&gt;();</span>

<span class="fc" id="L40">    private final Stack&lt;LabelNode&gt; redo_labels = new Stack&lt;LabelNode&gt;();</span>

    public StatementCodeGenerator(final FunctionCompiler function)
    {
<span class="fc" id="L44">        super(function.module, function.vars, function.instructions);</span>

<span class="fc" id="L46">        this.function = function;</span>
<span class="fc" id="L47">    }</span>

    @Override
    public void visit(final IfStatement object)
    {
        // Generated Bytecode
        //
        // &lt;condition-1&gt;
        // IF_FALSE @END_OF_CASE_1
        // &lt;body-1&gt;
        // GOTO @END
        // @END_OF_CASE_1
        //
        // &lt;condition-2&gt;
        // IF_FALSE @END_OF_CASE_2
        // &lt;body-2&gt;
        // GOTO @END
        // @END_OF_CASE_2
        //
        // &lt;condition-N&gt;
        // IF_FALSE @END_OF_CASE_N
        // &lt;body-N&gt;
        // GOTO @END
        // @END_OF_CASE_N
        //
        // &lt;body-else&gt;
        //
        // @END
        //////////////////////////////////////////////////////////////////////////////////////////
        //
        // At least one conditional case is present.
        //
        // The &lt;body-else&gt; is only generated, when an else-clause is present.
        //
        //////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L86">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L88">        final LabelNode END = new LabelNode();</span>

        // Put all the conditional cases into a single list.
<span class="fc" id="L91">        final List&lt;ConditionalCase&gt; cases = Lists.newLinkedList();</span>
<span class="fc" id="L92">        cases.add(object.getMainCase());</span>
<span class="fc" id="L93">        cases.addAll(object.getElifCases().asMutableList());</span>

<span class="fc bfc" id="L95" title="All 2 branches covered.">        for (ConditionalCase cc : cases)</span>
        {
<span class="fc" id="L97">            final LabelNode END_OF_CASE = new LabelNode();</span>

<span class="fc" id="L99">            compileCondition(cc.getCondition());</span>
<span class="fc" id="L100">            code.add(new JumpInsnNode(Utils.IF_FALSE, END_OF_CASE));</span>
            {
<span class="fc" id="L102">                cc.getBody().accept(this);</span>
<span class="fc" id="L103">                code.add(new JumpInsnNode(Opcodes.GOTO, END));</span>
            }
<span class="fc" id="L105">            code.add(END_OF_CASE);</span>
<span class="fc" id="L106">        }</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (object.getElseCase() != null)</span>
        {
<span class="fc" id="L110">            object.getElseCase().accept(this);</span>
        }

<span class="fc" id="L113">        code.add(END);</span>
<span class="fc" id="L114">    }</span>

    @Override
    public void visit(final WhenStatement object)
    {
        // Generated Bytecode
        //
        // &lt;condition&gt;
        // IF_FALSE @END
        // &lt;statement&gt;
        // @END
        /////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L130">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L132">        final LabelNode END = new LabelNode();</span>

<span class="fc" id="L134">        compileCondition(object.getCondition());</span>
<span class="fc" id="L135">        code.add(new JumpInsnNode(Utils.IF_FALSE, END));</span>
<span class="fc" id="L136">        object.getBody().accept(this);</span>
<span class="fc" id="L137">        code.add(END);</span>
<span class="fc" id="L138">    }</span>

    @Override
    public void visit(final GotoStatement object)
    {
        // Generated Bytecode
        //
        // GOTO @LABEL
        //
        ////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L152">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L154">        final String name = object.getLabel().getName();</span>

<span class="fc" id="L156">        final LabelNode node = function.labels.nodeOf(name);</span>

<span class="fc" id="L158">        code.add(new JumpInsnNode(Opcodes.GOTO, node));</span>
<span class="fc" id="L159">    }</span>

    @Override
    public void visit(final MarkerStatement object)
    {
        // Generated Bytecode
        //
        // @LABEL
        //
        ////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L173">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L175">        final String name = object.getLabel().getName();</span>

<span class="fc" id="L177">        final LabelNode node = function.labels.nodeOf(name);</span>

<span class="fc" id="L179">        code.add(node);</span>
<span class="fc" id="L180">    }</span>

    @Override
    public void visit(final BranchStatement object)
    {
        // Generated Bytecode
        //
        // &lt;index&gt;                                 - Evaluate the &lt;index&gt; expression.
        // &lt;conversion&gt;                            - Unbox or auto-widen the index, if needed.
        // TABLESWITCH label[0] , ... , label[n]   - Generate a jump-table.
        //
        ////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L196">        Utils.addLineNumber(code, object);</span>

        /**
         * Before we can generate any bytecode, we must convert the labels to ASM labels.
         */
<span class="fc" id="L201">        final int max = object.getLabels().size() - 1;</span>

<span class="fc" id="L203">        final LabelNode[] labels = new LabelNode[max + 1];</span>

<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (int i = 0; i &lt; labels.length; i++)</span>
        {
<span class="fc" id="L207">            labels[i] = function.labels.nodeOf(object.getLabels().get(i).getName());</span>
        }

<span class="fc" id="L210">        final LabelNode dflt = function.labels.nodeOf(object.getDefaultLabel().getName());</span>

        /**
         * Now we can perform the actual code generation.
         */
<span class="fc" id="L215">        object.getIndex().accept(this);</span>
<span class="fc" id="L216">        convert(program.typesystem.utils.PRIMITIVE_INT, object.getIndex());</span>

        /**
         * If only the default label is present, then then a simple goto must be generated.
         * Otherwise, a verifier error may result at runtime.
         */
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (labels.length != 0)</span>
        {
<span class="fc" id="L224">            code.add(new TableSwitchInsnNode(0, max, dflt, labels));</span>
        }
        else
        {
<span class="fc" id="L228">            code.add(new JumpInsnNode(Opcodes.GOTO, dflt));</span>
        }
<span class="fc" id="L230">    }</span>

    @Override
    public void visit(final WhileStatement object)
    {
        // Generated Bytecode
        //
        // @CONTINUE               - This is where continue-statements jump to.
        // &lt;condition&gt;             - Evaluate the condition.
        // UNBOX condition         - Unbox the condition, if needed.
        // IF_FALSE @BREAK         - If the condition was false, exit the loop.
        // @REDO                   - This is where redo-statements jump to.
        // &lt;body&gt;                  - Execute the body.
        // GOTO @CONTINUE          - Start the next iteration of the loop.
        // @BREAK                  - This is where break-statements jump to.
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L251">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L253">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L254">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L255">        final LabelNode REDO = new LabelNode();</span>

<span class="fc" id="L257">        code.add(CONTINUE);</span>
<span class="fc" id="L258">        compileCondition(object.getCondition());</span>
<span class="fc" id="L259">        code.add(new JumpInsnNode(Utils.IF_FALSE, BREAK));</span>
<span class="fc" id="L260">        code.add(REDO);</span>
        {
<span class="fc" id="L262">            break_labels.push(BREAK);</span>
<span class="fc" id="L263">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L264">            redo_labels.push(REDO);</span>

<span class="fc" id="L266">            object.getBody().accept(this);</span>

<span class="fc" id="L268">            break_labels.pop();</span>
<span class="fc" id="L269">            continue_labels.pop();</span>
<span class="fc" id="L270">            redo_labels.pop();</span>
        }
<span class="fc" id="L272">        code.add(new JumpInsnNode(Opcodes.GOTO, CONTINUE));</span>
<span class="fc" id="L273">        code.add(BREAK);</span>
<span class="fc" id="L274">    }</span>

    @Override
    public void visit(final UntilStatement object)
    {
        // Generated Bytecode
        //
        // @CONTINUE               - This is where continue-statements jump to.
        // &lt;condition&gt;             - Evaluate the condition.
        // UNBOX condition         - Unbox the condition, if needed.
        // IF_TRUE @BREAK          - If the condition was true, exit the loop.
        // @REDO                   - This is where redo-statements jump to.
        // &lt;body&gt;                  - Execute the body.
        // GOTO @CONTINUE          - Start the next iteration of the loop.
        // @BREAK                  - This is where break-statements jump to.
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L295">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L297">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L298">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L299">        final LabelNode REDO = new LabelNode();</span>

<span class="fc" id="L301">        code.add(CONTINUE);</span>
<span class="fc" id="L302">        compileCondition(object.getCondition());</span>
<span class="fc" id="L303">        code.add(new JumpInsnNode(Utils.IF_TRUE, BREAK));</span>
<span class="fc" id="L304">        code.add(REDO);</span>
        {
<span class="fc" id="L306">            break_labels.push(BREAK);</span>
<span class="fc" id="L307">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L308">            redo_labels.push(REDO);</span>

<span class="fc" id="L310">            object.getBody().accept(this);</span>

<span class="fc" id="L312">            break_labels.pop();</span>
<span class="fc" id="L313">            continue_labels.pop();</span>
<span class="fc" id="L314">            redo_labels.pop();</span>
        }
<span class="fc" id="L316">        code.add(new JumpInsnNode(Opcodes.GOTO, CONTINUE));</span>
<span class="fc" id="L317">        code.add(BREAK);</span>
<span class="fc" id="L318">    }</span>

    @Override
    public void visit(final DoWhileStatement object)
    {
        // Generated Bytecode:
        //
        // @TOP              - This is where each iteration starts.
        // @REDO             - This is where redo-statements jump to.
        // &lt;body&gt;            - Execute the body.
        // @CONTINUE         - This is where continue-statements jump to.
        // &lt;condition&gt;       - Evaluate the condition.
        // UNBOX condition   - Unbox the condition, if needed.
        // IF_TRUE @TOP      - If the condition was true, start the next iteration.
        // @BREAK            - This is where break-statements jump to.
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L339">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L341">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L342">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L343">        final LabelNode REDO = new LabelNode();</span>
<span class="fc" id="L344">        final LabelNode TOP = new LabelNode();</span>

<span class="fc" id="L346">        code.add(TOP);</span>
<span class="fc" id="L347">        code.add(REDO);</span>
        {
<span class="fc" id="L349">            break_labels.push(BREAK);</span>
<span class="fc" id="L350">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L351">            redo_labels.push(REDO);</span>

<span class="fc" id="L353">            object.getBody().accept(this);</span>

<span class="fc" id="L355">            break_labels.pop();</span>
<span class="fc" id="L356">            continue_labels.pop();</span>
<span class="fc" id="L357">            redo_labels.pop();</span>
        }
<span class="fc" id="L359">        code.add(CONTINUE);</span>
<span class="fc" id="L360">        compileCondition(object.getCondition());</span>
<span class="fc" id="L361">        code.add(new JumpInsnNode(Utils.IF_TRUE, TOP));</span>
<span class="fc" id="L362">        code.add(BREAK);</span>
<span class="fc" id="L363">    }</span>

    @Override
    public void visit(final DoUntilStatement object)
    {
        // Generated Bytecode:
        //
        // @TOP              - This is where each iteration starts.
        // @REDO             - This is where redo-statements jump to.
        // &lt;body&gt;            - Execute the body.
        // @CONTINUE         - This is where continue-statements jump to.
        // &lt;condition&gt;       - Evaluate the condition.
        // UNBOX condition   - Unbox the condition, if needed.
        // IF_FALSE @TOP     - If the condition was false, start the next iteration.
        // @BREAK            - This is where break-statements jump to.
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L384">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L386">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L387">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L388">        final LabelNode REDO = new LabelNode();</span>
<span class="fc" id="L389">        final LabelNode TOP = new LabelNode();</span>

<span class="fc" id="L391">        code.add(TOP);</span>
<span class="fc" id="L392">        code.add(REDO);</span>
        {
<span class="fc" id="L394">            break_labels.push(BREAK);</span>
<span class="fc" id="L395">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L396">            redo_labels.push(REDO);</span>

<span class="fc" id="L398">            object.getBody().accept(this);</span>

<span class="fc" id="L400">            break_labels.pop();</span>
<span class="fc" id="L401">            continue_labels.pop();</span>
<span class="fc" id="L402">            redo_labels.pop();</span>
        }
<span class="fc" id="L404">        code.add(CONTINUE);</span>
<span class="fc" id="L405">        compileCondition(object.getCondition());</span>
<span class="fc" id="L406">        code.add(new JumpInsnNode(Utils.IF_FALSE, TOP));</span>
<span class="fc" id="L407">        code.add(BREAK);</span>
<span class="fc" id="L408">    }</span>

    @Override
    public void visit(final ForeverStatement object)
    {
        // Generated Bytecode:
        //
        // @CONTINUE          - This is where continue-statements jump to.
        // @REDO              - This is where redo-statements jump to.
        // &lt;body&gt;             - Execute the body.
        // GOTO @CONTINUE     - Start the next iteration of the loop.
        // @BREAK             - This is where break-statements jump to.
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L426">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L428">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L429">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L430">        final LabelNode REDO = new LabelNode();</span>

<span class="fc" id="L432">        code.add(CONTINUE);</span>
<span class="fc" id="L433">        code.add(REDO);</span>
        {
<span class="fc" id="L435">            break_labels.push(BREAK);</span>
<span class="fc" id="L436">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L437">            redo_labels.push(REDO);</span>

<span class="fc" id="L439">            object.getBody().accept(this);</span>

<span class="fc" id="L441">            break_labels.pop();</span>
<span class="fc" id="L442">            continue_labels.pop();</span>
<span class="fc" id="L443">            redo_labels.pop();</span>
        }
<span class="fc" id="L445">        code.add(new JumpInsnNode(Opcodes.GOTO, CONTINUE));</span>
<span class="fc" id="L446">        code.add(BREAK);</span>
<span class="fc" id="L447">    }</span>

    @Override
    public void visit(final ForStatement object)
    {
        // Generated Bytecode:
        //
        // &lt;initializer&gt;        - Evaluate the initializer.
        // UNBOX initializer    - Unbox the initializer, if needed.
        // ISTORE assignee      - Place the initializer into the assignee variable.
        //
        // @TOP                 - This is where each loop iteration starts.
        //
        // &lt;condition&gt;          - Evaluate the condition.
        // UNBOX condition      - Unbox the condition, if needed.
        // IF_FALSE @BREAK      - If the condition was false, exit the loop.
        //
        // @REDO                - This is where redo-statements jump to.
        //
        // &lt;body&gt;               - Execute the body.
        //
        // @CONTINUE            - This is where continue-statements jump to.
        //
        // &lt;next&gt;               - Evaluate the modifier.
        // UNBOX next           - Unbox the modifier, if needed.
        // ISTORE assignee      - Place the modifier (aka next value) into the assignee variable.
        //
        // GOTO @TOP            - Start the next loop iteration.
        //
        // @BREAK               - This is where break-statements jump to.
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L483">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L485">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L486">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L487">        final LabelNode REDO = new LabelNode();</span>
<span class="fc" id="L488">        final LabelNode TOP = new LabelNode();</span>

<span class="fc" id="L490">        object.getInitializer().accept(this);</span>
<span class="fc" id="L491">        convert(program.typesystem.utils.PRIMITIVE_INT, object.getInitializer());</span>
<span class="fc" id="L492">        vars.store(object.getVariable().getName());</span>

<span class="fc" id="L494">        code.add(TOP);</span>
<span class="fc" id="L495">        compileCondition(object.getCondition());</span>
<span class="fc" id="L496">        code.add(new JumpInsnNode(Utils.IF_FALSE, BREAK));</span>
<span class="fc" id="L497">        code.add(REDO);</span>
        {
<span class="fc" id="L499">            break_labels.push(BREAK);</span>
<span class="fc" id="L500">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L501">            redo_labels.push(REDO);</span>

<span class="fc" id="L503">            object.getBody().accept(this);</span>

<span class="fc" id="L505">            code.add(CONTINUE);</span>

<span class="fc" id="L507">            object.getNext().accept(this);</span>
<span class="fc" id="L508">            convert(program.typesystem.utils.PRIMITIVE_INT, object.getNext());</span>
<span class="fc" id="L509">            vars.store(object.getVariable().getName());</span>

<span class="fc" id="L511">            break_labels.pop();</span>
<span class="fc" id="L512">            continue_labels.pop();</span>
<span class="fc" id="L513">            redo_labels.pop();</span>
        }
<span class="fc" id="L515">        code.add(new JumpInsnNode(Opcodes.GOTO, TOP));</span>
<span class="fc" id="L516">        code.add(BREAK);</span>
<span class="fc" id="L517">    }</span>

    @Override
    public void visit(final ForeachStatement object)
    {
        // Generated Bytecode:
        //
        // &lt;iterable&gt;                           - Evaluate the iterable.
        // INVOKEINTERFACE iterable.iterator()  - Get an Iterator from the Iterable.
        // ASTORE iterator                      - Save the iterator for later.
        //
        // @CONTINUE                            - This is where each iteration starts.
        // ALOAD iterator                       - Load the iterator object.
        // INVOKEINTERFACE iterator.hasNext()   - Ask whether the iterator has more elements.
        // IF_FALSE @BREAK                      - If no, we can now exit the loop.
        //
        // ALOAD iterator                       - Load the iterator object.
        // INVOKEINTERFACE iterator.next()      - Get the next element in the sequence.
        // CHECKCAST type                       - Cast the element to the required type.
        // ASTORE variable                      - Put the element into the variable.
        //
        // @REDO                                - This is where redo-statements jump to.
        //
        // &lt;body&gt;                               - Execute the body of the loop.
        // GOTO CONTINUE                        - Goto the start of the next iteration.
        //
        // @BREAK                               - This is the exit-point of the loop.
        //
        // ACONST_NULL                          - Load null.
        // ASTORE iterator                      - Clear the iterator temporary variable.
        //
        //////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L553">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L555">        final IDeclaredType type = (IDeclaredType) function.module.imports.resolveVariableType(object.getType());</span>

<span class="fc" id="L557">        final LabelNode BREAK = new LabelNode();</span>
<span class="fc" id="L558">        final LabelNode CONTINUE = new LabelNode();</span>
<span class="fc" id="L559">        final LabelNode REDO = new LabelNode();</span>

        /**
         * Declare the temporary variable that will store the iterator.
         */
<span class="fc" id="L564">        final String iterator = &quot;autumn$temp$&quot; + F.unique();</span>
<span class="fc" id="L565">        function.allocator.declareTemp(iterator, program.typesystem.utils.OBJECT);</span>

        // Evaluate the iterable.
<span class="fc" id="L568">        object.getIterable().accept(this);</span>

        // Get an iterator over the iterable.
<span class="fc" id="L571">        code.add(new MethodInsnNode(Opcodes.INVOKEINTERFACE,</span>
                                    &quot;java/lang/Iterable&quot;,
                                    &quot;iterator&quot;,
                                    &quot;()Ljava/util/Iterator;&quot;));

        // Save the iterator for later.
<span class="fc" id="L577">        function.vars.store(iterator);</span>

<span class="fc" id="L579">        code.add(CONTINUE);</span>

        // If the iterator is consumed, then break out of the loop.
<span class="fc" id="L582">        function.vars.load(iterator);</span>
<span class="fc" id="L583">        code.add(new MethodInsnNode(Opcodes.INVOKEINTERFACE,</span>
                                    &quot;java/util/Iterator&quot;,
                                    &quot;hasNext&quot;,
                                    &quot;()Z&quot;));
<span class="fc" id="L587">        code.add(new JumpInsnNode(Utils.IF_FALSE, BREAK));</span>

        // Get the next element from the iterator.
<span class="fc" id="L590">        function.vars.load(iterator);</span>
<span class="fc" id="L591">        code.add(new MethodInsnNode(Opcodes.INVOKEINTERFACE,</span>
                                    &quot;java/util/Iterator&quot;,
                                    &quot;next&quot;,
                                    &quot;()Ljava/lang/Object;&quot;));

        // Cast the value to the expected type.
<span class="fc" id="L597">        code.add(new TypeInsnNode(Opcodes.CHECKCAST, Utils.internalName(type)));</span>

        // Assign the value to the variable.
<span class="fc" id="L600">        function.vars.store(object.getVariable().getName());</span>

        // Execute the body of the loop.
<span class="fc" id="L603">        code.add(REDO);</span>
        {
<span class="fc" id="L605">            break_labels.push(BREAK);</span>
<span class="fc" id="L606">            continue_labels.push(CONTINUE);</span>
<span class="fc" id="L607">            redo_labels.push(REDO);</span>

<span class="fc" id="L609">            object.getBody().accept(this);</span>

<span class="fc" id="L611">            break_labels.pop();</span>
<span class="fc" id="L612">            continue_labels.pop();</span>
<span class="fc" id="L613">            redo_labels.pop();</span>
        }
<span class="fc" id="L615">        code.add(new JumpInsnNode(Opcodes.GOTO, CONTINUE));</span>
<span class="fc" id="L616">        code.add(BREAK);</span>

        // Clear the iterator temporary variable.
<span class="fc" id="L619">        code.add(new InsnNode(Opcodes.ACONST_NULL));</span>
<span class="fc" id="L620">        function.vars.store(iterator);</span>
<span class="fc" id="L621">    }</span>

    @Override
    public void visit(final BreakStatement object)
    {
        // Generated Bytecode:
        //
        // GOTO @BREAK
        //
        ////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L635">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L637">        final LabelNode BREAK = break_labels.peek();</span>

<span class="fc" id="L639">        code.add(new JumpInsnNode(Opcodes.GOTO, BREAK));</span>
<span class="fc" id="L640">    }</span>

    @Override
    public void visit(final ContinueStatement object)
    {
        // Generated Bytecode:
        //
        // GOTO @CONTINUE
        //
        ////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L654">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L656">        final LabelNode CONTINUE = continue_labels.peek();</span>

<span class="fc" id="L658">        code.add(new JumpInsnNode(Opcodes.GOTO, CONTINUE));</span>
<span class="fc" id="L659">    }</span>

    @Override
    public void visit(final RedoStatement object)
    {
        // Generated Bytecode:
        //
        // GOTO @REDO
        //
        ////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L673">        Utils.addLineNumber(code, object);</span>


<span class="fc" id="L676">        final LabelNode REDO = redo_labels.peek();</span>

<span class="fc" id="L678">        code.add(new JumpInsnNode(Opcodes.GOTO, REDO));</span>
<span class="fc" id="L679">    }</span>

    @Override
    public void visit(final VarStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L687">        Utils.addLineNumber(code, object);</span>

        /**
         * Get the name of the variable that is being assigned to.
         */
<span class="fc" id="L692">        final String assignee = object.getVariable().getName();</span>

        /**
         * Generate the bytecode that produces the value.
         */
<span class="fc" id="L697">        object.getValue().accept(this);</span>

        /**
         * Generate the bytecode that actually performs the assignment.
         */
<span class="fc" id="L702">        vars.store(assignee);</span>
<span class="fc" id="L703">    }</span>

    @Override
    public void visit(final ValStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L711">        Utils.addLineNumber(code, object);</span>

        /**
         * Get the name of the variable that is being assigned to.
         */
<span class="fc" id="L716">        final String name = object.getVariable().getName();</span>

        /**
         * Generate the bytecode that produces the value.
         */
<span class="fc" id="L721">        object.getValue().accept(this);</span>

        /**
         * Generate the bytecode that actually performs the assignment.
         */
<span class="fc" id="L726">        vars.store(name);</span>
<span class="fc" id="L727">    }</span>

    @Override
    public void visit(final LetStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L735">        Utils.addLineNumber(code, object);</span>

        /**
         * Get the name of the variable that is being assigned to.
         */
<span class="fc" id="L740">        final String name_of_variable = object.getVariable().getName();</span>

        /**
         * Get the type of the variable that is being assigned to.
         */
<span class="fc" id="L745">        final IType type_of_variable = function.allocator.typeOf(name_of_variable);</span>

        /**
         * Generate the bytecode that produces the value.
         */
<span class="fc" id="L750">        object.getValue().accept(this);</span>

        /**
         * Generate the bytecode that performs auto-boxing, auto-unboxing, or coercion, if needed.
         */
<span class="fc" id="L755">        convert(type_of_variable, object.getValue());</span>

        /**
         * Generate the bytecode that actually performs the assignment.
         */
<span class="fc" id="L760">        vars.store(object.getVariable().getName());</span>
<span class="fc" id="L761">    }</span>

    @Override
    public void visit(final LambdaStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L769">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L771">        final LambdaCompiler lambda = program.symbols.lambdas.get(object);</span>

        /**
         * Create a new instance of the lambda.
         * Capture the local variables.
         * Load the lambda onto the operand-stack.
         */
<span class="fc" id="L778">        lambda.load(code);</span>

        /**
         * Place the lambda object into the variable that will store it.
         */
<span class="fc" id="L783">        function.vars.store(object.getVariable().getName());</span>
<span class="fc" id="L784">    }</span>

    @Override
    public void visit(final DelegateStatement object)
    {
<span class="fc" id="L789">        final IClassType functor = module.imports.resolveDefinedFunctorType(object.getType());</span>

<span class="fc" id="L791">        final IMethod handler = program.symbols.delegates.get(object);</span>

        // Generated Bytecode:
        //
        // NEW functor                                    - Create a new uninitialized instance of the functor-type.
        // DUP                                            - Duplicate the reference to the functor.
        // INVOKESTATIC module.instance()                 - Get the singleton instance of the module that contains the delegate function.
        // LDC name                                       - Load the name of the delegate function.
        // INVOKESTATIC Helpers.delegate(Module, String)  - Create the delegate object.
        // INVOKESPECIAL functor.&lt;init&gt;(Functor)          - Wrap the delegate object in the functor object.
        // STORE variable                                 - Place the wrapped delegate object into the variable.
        //
        ////////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L808">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L810">        code.add(new TypeInsnNode(Opcodes.NEW, Utils.internalName(functor)));</span>

<span class="fc" id="L812">        code.add(new InsnNode(Opcodes.DUP));</span>

<span class="fc" id="L814">        code.add(new MethodInsnNode(Opcodes.INVOKESTATIC,</span>
<span class="fc" id="L815">                                    Utils.internalName(handler.getOwner()),</span>
                                    &quot;instance&quot;,
<span class="fc" id="L817">                                    &quot;()&quot; + handler.getOwner().getDescriptor()));</span>

<span class="fc" id="L819">        code.add(new LdcInsnNode(handler.getName()));</span>

<span class="fc" id="L821">        Utils.invoke(code,</span>
                     Opcodes.INVOKESTATIC,
                     Helpers.class,
                     Delegate.class,
                     &quot;delegate&quot;,
                     autumn.lang.Module.class,
                     String.class);

<span class="fc" id="L829">        code.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
<span class="fc" id="L830">                                    Utils.internalName(functor),</span>
                                    &quot;&lt;init&gt;&quot;,
                                    &quot;(Lautumn/lang/TypedFunctor;)V&quot;));

<span class="fc" id="L834">        function.vars.store(object.getVariable().getName());</span>
<span class="fc" id="L835">    }</span>

    @Override
    public void visit(final SequenceStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L843">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L845">        final int break_count = break_labels.size();</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">        for (IStatement s : object.getElements())</span>
        {
<span class="fc" id="L849">            s.accept(this);</span>
<span class="fc" id="L850">        }</span>

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">        assert break_labels.size() == break_count;</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        assert continue_labels.size() == break_count;</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        assert redo_labels.size() == break_count;</span>
<span class="fc" id="L855">    }</span>

    @Override
    public void visit(final ExpressionStatement object)
    {
        // Generated Bytecode:
        //
        // &lt;expression&gt;      - Evaluate the expression.
        // POP-X             - Pop the value, if any, of the expression off of the stack.
        //
        ///////////////////////////////////////////////////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L870">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L872">        object.getExpression().accept(this);</span>

<span class="fc" id="L874">        final IType type = program.symbols.expressions.get(object.getExpression());</span>
<span class="fc" id="L875">        code.add(Utils.selectPop(type));</span>
<span class="fc" id="L876">    }</span>

    @Override
    public void visit(final NopStatement object)
    {
        // Generated Bytecode:
        //
        // NOP
        //
        //////////////////////////////////////

        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L890">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L892">        code.add(new InsnNode(Opcodes.NOP));</span>
<span class="fc" id="L893">    }</span>

    @Override
    public void visit(final TryCatchStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L901">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L903">        final List&lt;ExceptionHandler&gt; handlers = program.symbols.handlers.get(object);</span>

        /**
         * This label marks the start of the protected region.
         */
<span class="fc" id="L908">        final LabelNode START = new LabelNode();</span>

        /**
         * This label marks the end of the protected region.
         */
<span class="fc" id="L913">        final LabelNode END = new LabelNode();</span>

        /**
         * This label node marks the end of the entire try-catch construct.
         */
<span class="fc" id="L918">        final LabelNode EXIT = new LabelNode();</span>

        // Enter the protected region.
<span class="fc" id="L921">        code.add(START);</span>

        // Execute the protected region.
        // If an exception occurs, jump directly to the appropriate handler.
<span class="fc" id="L925">        object.getBody().accept(this);</span>

        // Exit the protected region.
<span class="fc" id="L928">        code.add(END);</span>

        // Since no exception occurred, skip the exception handlers.
<span class="fc" id="L931">        code.add(new JumpInsnNode(Opcodes.GOTO, EXIT));</span>

        // Compile the exception handlers.
<span class="fc bfc" id="L934" title="All 2 branches covered.">        for (ExceptionHandler handler : handlers)</span>
        {
            // Compile a single exception handler.
<span class="fc" id="L937">            generateExceptionHandler(START, END, handler);</span>

            // If the handler was executed, then immediately exit the try-catch construct.
<span class="fc" id="L940">            code.add(new JumpInsnNode(Opcodes.GOTO, EXIT));</span>
<span class="fc" id="L941">        }</span>

        // Exit the try-catch construct.
<span class="fc" id="L944">        code.add(EXIT);</span>
<span class="fc" id="L945">    }</span>

    private void generateExceptionHandler(final LabelNode start,
                                          final LabelNode end,
                                          final ExceptionHandler handler)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L954">        Utils.addLineNumber(code, handler);</span>

        /**
         * This is the name of the variable that will contain the exception object.
         */
<span class="fc" id="L959">        final String variable = handler.getVariable().getName();</span>

        /**
         * This is the name of the type that this exception-handler handles.
         */
<span class="fc" id="L964">        final String type = Utils.internalName((IDeclaredType) module.imports.resolveReturnType(handler.getType()));</span>

        /**
         * This label marks the entry-point of this try-catch handler.
         */
<span class="fc" id="L969">        final LabelNode CATCHER = new LabelNode();</span>

        /**
         * This object describes the simplified try-catch block created by this exception-handler.
         */
<span class="fc" id="L974">        final TryCatchBlockNode block = new TryCatchBlockNode(start, end, CATCHER, type);</span>

        // Add the exception-handler to the function.
<span class="fc" id="L977">        function.trycatches.add(block);</span>

        // Enter the exception handler.
<span class="fc" id="L980">        code.add(CATCHER);</span>

        // Store the exception object in the appropriate variable.
<span class="fc" id="L983">        vars.store(variable);</span>

        // Execute the exception handling code.
<span class="fc" id="L986">        handler.getBody().accept(this);</span>
<span class="fc" id="L987">    }</span>

    @Override
    public void visit(final ThrowStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L995">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L997">        object.getValue().accept(this);</span>

<span class="fc" id="L999">        code.add(new InsnNode(Opcodes.ATHROW));</span>
<span class="fc" id="L1000">    }</span>

    @Override
    public void visit(final AssertStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L1008">        Utils.addLineNumber(code, object);</span>

        final String descriptor;

<span class="fc" id="L1012">        final LabelNode END = new LabelNode();</span>

<span class="fc" id="L1014">        compileCondition(object.getCondition());</span>

<span class="fc" id="L1016">        code.add(new JumpInsnNode(Utils.IF_TRUE, END));</span>

<span class="fc" id="L1018">        code.add(new TypeInsnNode(Opcodes.NEW, &quot;autumn/lang/exceptions/AssertionFailedException&quot;));</span>

<span class="fc" id="L1020">        code.add(new InsnNode(Opcodes.DUP));</span>

<span class="fc" id="L1022">        code.add(new LdcInsnNode(object.getLocation().getFile().toString()));</span>

<span class="fc" id="L1024">        code.add(new LdcInsnNode(object.getLocation().getLine()));</span>

<span class="fc bfc" id="L1026" title="All 2 branches covered.">        if (object.getMessage() == null)</span>
        {
<span class="fc" id="L1028">            descriptor = &quot;(Ljava/lang/String;I)V&quot;;</span>
        }
        else
        {
<span class="fc" id="L1032">            descriptor = &quot;(Ljava/lang/String;ILjava/lang/String;)V&quot;;</span>

<span class="fc" id="L1034">            object.getMessage().accept(this);</span>
        }

<span class="fc" id="L1037">        code.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
                                    &quot;autumn/lang/exceptions/AssertionFailedException&quot;,
                                    &quot;&lt;init&gt;&quot;,
                                    descriptor));

<span class="fc" id="L1042">        code.add(new InsnNode(Opcodes.ATHROW));</span>

<span class="fc" id="L1044">        code.add(END);</span>
<span class="fc" id="L1045">    }</span>

    @Override
    public void visit(final AssumeStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L1053">        Utils.addLineNumber(code, object);</span>

        final String descriptor;

<span class="fc" id="L1057">        final LabelNode END = new LabelNode();</span>

<span class="fc" id="L1059">        code.add(new MethodInsnNode(Opcodes.INVOKESTATIC,</span>
                                    &quot;autumn/lang/compiler/Autumn&quot;,
                                    &quot;isAssumeOn&quot;,
                                    &quot;()Z&quot;));

<span class="fc" id="L1064">        code.add(new JumpInsnNode(Utils.IF_FALSE, END));</span>

<span class="fc" id="L1066">        compileCondition(object.getCondition());</span>

<span class="fc" id="L1068">        code.add(new JumpInsnNode(Utils.IF_TRUE, END));</span>

<span class="fc" id="L1070">        code.add(new TypeInsnNode(Opcodes.NEW, &quot;autumn/lang/exceptions/AssumptionFailedException&quot;));</span>

<span class="fc" id="L1072">        code.add(new InsnNode(Opcodes.DUP));</span>

<span class="fc" id="L1074">        code.add(new LdcInsnNode(object.getLocation().getFile().toString()));</span>

<span class="fc" id="L1076">        code.add(new LdcInsnNode(object.getLocation().getLine()));</span>

<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (object.getMessage() == null)</span>
        {
<span class="fc" id="L1080">            descriptor = &quot;(Ljava/lang/String;I)V&quot;;</span>
        }
        else
        {
<span class="fc" id="L1084">            descriptor = &quot;(Ljava/lang/String;ILjava/lang/String;)V&quot;;</span>

<span class="fc" id="L1086">            object.getMessage().accept(this);</span>
        }

<span class="fc" id="L1089">        code.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
                                    &quot;autumn/lang/exceptions/AssumptionFailedException&quot;,
                                    &quot;&lt;init&gt;&quot;,
                                    descriptor));

<span class="fc" id="L1094">        code.add(new InsnNode(Opcodes.ATHROW));</span>

<span class="fc" id="L1096">        code.add(END);</span>
<span class="fc" id="L1097">    }</span>

    @Override
    public void visit(final ReturnVoidStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L1105">        Utils.addLineNumber(code, object);</span>

        /**
         * Return from the function immediately.
         */
<span class="fc" id="L1110">        code.add(new InsnNode(Opcodes.RETURN));</span>
<span class="fc" id="L1111">    }</span>

    @Override
    public void visit(final ReturnValueStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L1119">        Utils.addLineNumber(code, object);</span>


        /**
         * Evaluate the expression that produces the value to return.
         */
<span class="fc" id="L1125">        object.getValue().accept(this);</span>

        /**
         * Perform auto-boxing or auto-unboxing, if needed.
         */
<span class="fc" id="L1130">        convert(function.type.getReturnType(), object.getValue());</span>

        /**
         * Return from the function immediately.
         */
<span class="fc" id="L1135">        code.add(Utils.selectReturnInsn(function.type.getReturnType()));</span>
<span class="fc" id="L1136">    }</span>

    @Override
    public void visit(final RecurStatement object)
    {
        /**
         * Embed the line number in the bytecode for debugging purposes.
         */
<span class="fc" id="L1144">        Utils.addLineNumber(code, object);</span>

<span class="fc" id="L1146">        int parameter_index = 0;</span>

        /**
         * Evaluate the arguments and store them in the parameter variables.
         */
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        for (IExpression arg : object.getArguments())</span>
        {
<span class="fc" id="L1153">            final String parameter = function.node // Get the function's AST node.</span>
<span class="fc" id="L1154">                    .getParameters() // Get formal-parameter-list.</span>
<span class="fc" id="L1155">                    .getParameters() // From the formal-parameter-list, get the actual list.</span>
<span class="fc" id="L1156">                    .asMutableList() // Convert the list, because we need the get(int) method.</span>
<span class="fc" id="L1157">                    .get(parameter_index++) // Get the formal-parameter from the list.</span>
<span class="fc" id="L1158">                    .getVariable() // We only need the variable, not the type.</span>
<span class="fc" id="L1159">                    .getName(); // Get the name of the variable as a string.</span>

            /**
             * Generate the argument's bytecode.
             */
<span class="fc" id="L1164">            arg.accept(this);</span>

            /**
             * Generate the bytecode that performs auto-boxing, auto-unboxing, and coercions, if needed.
             */
<span class="fc" id="L1169">            code.add(program.typesystem.utils.assign(program.symbols.expressions.get(arg),</span>
<span class="fc" id="L1170">                                                     function.allocator.typeOf(parameter)));</span>

            /**
             * Generate the bytecode that assigns the argument to the parameter's local-variable.
             */
<span class="fc" id="L1175">            function.vars.store(parameter);</span>
<span class="fc" id="L1176">        }</span>

        /**
         * Goto the start of the function.
         */
<span class="fc" id="L1181">        code.add(new JumpInsnNode(Opcodes.GOTO, function.recur_label));</span>
<span class="fc" id="L1182">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>