<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionTypeChecker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.compilers</a> &gt; <span class="el_source">ExpressionTypeChecker.java</span></div><h1>ExpressionTypeChecker.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.compilers;

import autumn.lang.compiler.ast.commons.IExpression;
import autumn.lang.compiler.ast.nodes.*;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IClassType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IConstructor;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IDeclaredType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IExpressionType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IField;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IReferenceType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IReturnType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IVariableType;
import com.mackenziehigh.autumn.lang.compiler.utils.Conversion;
import com.mackenziehigh.autumn.lang.compiler.utils.TypeSystemUtils;
import java.util.Collections;
import java.util.List;
import java.util.Set;

/**
 * An instance of this class performs type usage checking on an expression.
 *
 * @author Mackenzie High
 */
<span class="fc" id="L28">class ExpressionTypeChecker</span>
        extends AbstractTypeChecker
{
    /**
     * This field refers to the standard library method that implements identity-equality.
     */
    private final IMethod IDENTITY_EQUALITY;

    /**
     * This field refers to the standard library method that implements identity-inequality.
     */
    private final IMethod IDENTITY_INEQUALITY;

    /**
     * This object manages the allocation of local variables.
     */
    protected final VariableAllocator allocator;

    /**
     * Essentially, this is the enclosing function that is being compiled.
     */
    protected final AbstractFunctionCompiler abstract_function;

    /**
     * Sole Constructor.
     *
     * @param function is the function being compiled.
     * @param allocator manages the allocation of local variables.
     */
    public ExpressionTypeChecker(final AbstractFunctionCompiler function,
                                 final VariableAllocator allocator)
    {
<span class="fc" id="L60">        super(function);</span>

<span class="fc" id="L62">        Preconditions.checkNotNull(function);</span>
<span class="fc" id="L63">        Preconditions.checkNotNull(allocator);</span>

<span class="fc" id="L65">        this.abstract_function = function;</span>

<span class="fc" id="L67">        this.allocator = allocator;</span>

        // The Operators class in the standard library proivdes the operator implementations.
<span class="fc" id="L70">        final IDeclaredType OPERATORS = program.typesystem.utils.OPERATORS;</span>

        // Find the method that implements identity equality.
<span class="fc" id="L73">        this.IDENTITY_EQUALITY = TypeSystemUtils.find(OPERATORS.getMethods(),</span>
                                                      &quot;identityEquals&quot;,
                                                      &quot;(Ljava/lang/Object;Ljava/lang/Object;)Z&quot;);

        // Find the method that implements identity inequality.
<span class="fc" id="L78">        this.IDENTITY_INEQUALITY = TypeSystemUtils.find(OPERATORS.getMethods(),</span>
                                                        &quot;identityNotEquals&quot;,
                                                        &quot;(Ljava/lang/Object;Ljava/lang/Object;)Z&quot;);
<span class="fc" id="L81">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public AbstractFunctionCompiler function()
    {
<span class="fc" id="L89">        return abstract_function;</span>
    }

    @Override
    public void visit(final BooleanDatum object)
    {
        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L98">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>
<span class="fc" id="L99">    }</span>

    @Override
    public void visit(final CharDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L107">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Character.MIN_VALUE, Character.MAX_VALUE);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L112">        infer(object, program.typesystem.utils.PRIMITIVE_CHAR);</span>
<span class="fc" id="L113">    }</span>

    @Override
    public void visit(final ByteDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L121">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Byte.MIN_VALUE, Byte.MAX_VALUE);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L126">        infer(object, program.typesystem.utils.PRIMITIVE_BYTE);</span>
<span class="fc" id="L127">    }</span>

    @Override
    public void visit(final ShortDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L135">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Short.MIN_VALUE, Short.MAX_VALUE);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L140">        infer(object, program.typesystem.utils.PRIMITIVE_SHORT);</span>
<span class="fc" id="L141">    }</span>

    @Override
    public void visit(final IntDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L149">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Integer.MIN_VALUE, Integer.MAX_VALUE);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L154">        infer(object, program.typesystem.utils.PRIMITIVE_INT);</span>
<span class="fc" id="L155">    }</span>

    @Override
    public void visit(final LongDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L163">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Long.MIN_VALUE, Long.MAX_VALUE);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L168">        infer(object, program.typesystem.utils.PRIMITIVE_LONG);</span>
<span class="fc" id="L169">    }</span>

    @Override
    public void visit(final FloatDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L177">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Float.MIN_VALUE, Float.MAX_VALUE);</span>

<span class="fc" id="L179">        infer(object, program.typesystem.utils.PRIMITIVE_FLOAT);</span>
<span class="fc" id="L180">    }</span>

    @Override
    public void visit(final DoubleDatum object)
    {
        /**
         * Ensure that the literal can actually be compiled without losing information.
         */
<span class="fc" id="L188">        program.checker.checkLiteral(object, object.getValue().value(), object.getValue().source(), Double.MIN_VALUE, Double.MAX_VALUE);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L193">        infer(object, program.typesystem.utils.PRIMITIVE_DOUBLE);</span>
<span class="fc" id="L194">    }</span>

    @Override
    public void visit(final BigIntegerDatum object)
    {
        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L202">        infer(object, program.typesystem.utils.BIG_INTEGER);</span>
<span class="fc" id="L203">    }</span>

    @Override
    public void visit(final BigDecimalDatum object)
    {
        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L211">        infer(object, program.typesystem.utils.BIG_DECIMAL);</span>
<span class="fc" id="L212">    }</span>

    @Override
    public void visit(final StringDatum object)
    {
<span class="fc" id="L217">        program.checker.requireWellFormedStringLiteral(object);</span>

        /**
         * Assign a datatype to the literal based on its syntactic form.
         */
<span class="fc" id="L222">        infer(object, program.typesystem.utils.STRING);</span>
<span class="fc" id="L223">    }</span>

    @Override
    public void visit(final NullDatum object)
    {
<span class="fc" id="L228">        infer(object, program.typesystem.utils.NULL);</span>
<span class="fc" id="L229">    }</span>

    @Override
    public void visit(final VariableDatum object)
    {
        // The variable must have already been declared.
<span class="fc" id="L235">        program.checker.checkDeclared(allocator, object.getVariable());</span>

        // The variable must be in-scope.
<span class="fc" id="L238">        program.checker.checkScope(allocator, object.getVariable());</span>

        // This is the type of the variable based on its declaration.
<span class="fc" id="L241">        final IVariableType type = allocator.typeOf(object.getVariable().getName());</span>

        // A variable datum returns the value stored in the variable.
        // Thus, the datum's type is the type of the variable.
<span class="fc" id="L245">        infer(object, type);</span>
<span class="fc" id="L246">    }</span>

    @Override
    public void visit(final ClassDatum object)
    {
        // Perform type-checking.
        // This call will throw an exception, if the type does not exist, etc.
<span class="fc" id="L253">        module.imports.resolveReturnType(object.getType());</span>

<span class="fc" id="L255">        infer(object, program.typesystem.utils.CLASS);</span>
<span class="fc" id="L256">    }</span>

    @Override
    public void visit(final PrognExpression object)
    {
        /**
         * A progn-expression cannot be empty.
         */
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (object.getElements().isEmpty())</span>
        {
<span class="nc" id="L266">            program.checker.reportEmptyProgn(object);</span>
        }

        /**
         * Visit and type-check each one of the elements in the sequence.
         */
<span class="fc" id="L272">        IExpression last = null;</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (IExpression x : object.getElements())</span>
        {
<span class="fc" id="L276">            x.accept(this);</span>

<span class="fc" id="L278">            last = x;</span>
<span class="fc" id="L279">        }</span>

<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        assert last != null;</span>

        /**
         * The last element must return a value.
         */
<span class="fc" id="L286">        program.checker.requireNonVoid(last);</span>

        /**
         * The return-type of the progn-expression is the return-type of its last element.
         */
<span class="fc" id="L291">        final IExpressionType type = program.symbols.expressions.get(last);</span>
<span class="fc" id="L292">        infer(object, type);</span>
<span class="fc" id="L293">    }</span>

    @Override
    public void visit(final ListExpression object)
    {
        // Visit the elements.
<span class="fc" id="L299">        object.getElements().accept(this);</span>

        // A list-expression returns type java.util.List.
<span class="fc" id="L302">        infer(object, program.typesystem.utils.LIST);</span>

        // Type-check the elements.
<span class="fc" id="L305">        program.checker.requireArguments(object.getElements());</span>
<span class="fc" id="L306">    }</span>

    @Override
    public void visit(final ListComprehensionExpression object)
    {
        /**
         * A list-comprehension returns type java.util.List.
         */
<span class="fc" id="L314">        infer(object, program.typesystem.utils.LIST);</span>

        /**
         * Type-check the iterable.
         */
<span class="fc" id="L319">        object.getIterable().accept(this);</span>
<span class="fc" id="L320">        program.checker.requireIterable(object.getIterable());</span>

        try
        {
            /**
             * A list-comprehension defines a nested scope that covers modifier and condition.
             */
<span class="fc" id="L327">            allocator.enterScope();</span>

            /**
             * Declare the variable and type-check the type.
             */
<span class="fc" id="L332">            final Variable variable = object.getVariable();</span>
<span class="fc" id="L333">            final IReferenceType type = module.imports.resolveReferenceType(object.getType());</span>
<span class="fc" id="L334">            super.declareVar(variable, type, false);</span>

            /**
             * Type-check the modifier.
             */
<span class="fc" id="L339">            object.getModifier().accept(this);</span>
<span class="fc" id="L340">            program.checker.requireNonVoid(object.getModifier());</span>

            /**
             * Type-check the condition.
             */
<span class="fc bfc" id="L345" title="All 2 branches covered.">            if (object.getCondition() != null)</span>
            {
<span class="fc" id="L347">                condition(object.getCondition());</span>
            }
        }
<span class="fc" id="L350">        catch (TypeCheckFailed ex)</span>
        {
<span class="fc" id="L352">            throw ex;</span>
        }
        finally
        {
            /**
             * This must always be done; otherwise, the scope management could get messed up.
             */
<span class="fc" id="L359">            allocator.exitScope();</span>
        }
<span class="fc" id="L361">    }</span>

    @Override
    public void visit(final DispatchExpression object)
    {
        /**
         * Visit and type-check the expressions that produce the arguments.
         */
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (IExpression arg : object.getArguments())</span>
        {
<span class="fc" id="L371">            arg.accept(this);</span>
<span class="fc" id="L372">        }</span>

        /**
         * This object will be used to perform both type-checking
         * and code-generation of the dispatch-expression.
         */
<span class="fc" id="L378">        final DispatchCompiler cmp = new DispatchCompiler(object,</span>
                                                          module,
                                                          allocator,
<span class="fc" id="L381">                                                          function().vars,</span>
<span class="fc" id="L382">                                                          object.getName().getName(),</span>
<span class="fc" id="L383">                                                          object.getArguments().asMutableList());</span>

        /**
         * Find the overloads that will be included in the dispatch-table.
         */
<span class="fc" id="L388">        cmp.resolve();</span>

        /**
         * Perform type-checking of the dispatch-expression itself.
         */
<span class="fc" id="L393">        cmp.check();</span>

        /**
         * We will need the dispatch-expression compiler later.
         */
<span class="fc" id="L398">        program.symbols.dispatches.put(object, cmp);</span>

        /**
         * The return-type of the expression is Object.
         */
<span class="fc" id="L403">        infer(object, program.typesystem.utils.OBJECT);</span>
<span class="fc" id="L404">    }</span>

    @Override
    public void visit(final CallStaticMethodExpression object)
    {
        /**
         * The compilation of static methods is abstracted,
         * because that are used for other things also,
         * such as operators.
         */
<span class="fc" id="L414">        callStaticMethod(object,</span>
<span class="fc" id="L415">                         object.getOwner(),</span>
<span class="fc" id="L416">                         object.getName(),</span>
<span class="fc" id="L417">                         object.getArguments());</span>
<span class="fc" id="L418">    }</span>

    @Override
    public void visit(final SetStaticFieldExpression object)
    {
        /**
         * Resolve the field.
         */
<span class="fc" id="L426">        final IField field = findStaticField(object, object.getOwner(), object.getName().getName());</span>

        /**
         * Visit and type-check the value.
         */
<span class="fc" id="L431">        object.getValue().accept(this);</span>

        /**
         * Ensure that the field is not readonly.
         */
<span class="fc" id="L436">        program.checker.requireNonFinalFieldAssignment(object, field);</span>

        /**
         * Ensure that the value can actually be assigned to the field.
         */
<span class="fc" id="L441">        program.checker.checkAssign(object, field.getType(), object.getValue());</span>

        /**
         * The return-type of the expression is void.
         */
<span class="fc" id="L446">        infer(object, program.typesystem.utils.VOID);</span>
<span class="fc" id="L447">    }</span>

    @Override
    public void visit(final GetStaticFieldExpression object)
    {
        /**
         * Resolve the field.
         */
<span class="fc" id="L455">        final IField field = findStaticField(object, object.getOwner(), object.getName().getName());</span>

        /**
         * The return-type of the expression is the type of the field.
         */
<span class="fc" id="L460">        infer(object, field.getType());</span>
<span class="fc" id="L461">    }</span>

    @Override
    public void visit(final NewExpression object)
    {
        /**
         * Get the type that is being instantiated.
         * This will throw an exception, if the type does not exist or is inaccessible.
         */
<span class="fc" id="L470">        final IClassType type = module.imports.resolveClassType(object.getType());</span>

        /**
         * Visit and type-check the arguments.
         */
<span class="fc" id="L475">        final List&lt;IExpressionType&gt; args = Lists.newLinkedList();</span>

<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (IExpression arg : object.getArguments())</span>
        {
<span class="fc" id="L479">            arg.accept(this);</span>
<span class="fc" id="L480">            args.add(program.symbols.expressions.get(arg));</span>
<span class="fc" id="L481">        }</span>

        /**
         * Resolve the constructor that will be invoked.
         */
<span class="fc" id="L486">        final List&lt;IConstructor&gt; ctors = program.typesystem.utils.resolveCtors(module.type,</span>
                                                                               type,
                                                                               args);

        /**
         * If no applicable constructor exists, issue a warning.
         */
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (ctors.isEmpty())</span>
        {
            // This will throw an exception.
<span class="nc" id="L496">            program.checker.reportNoSuchConstructor(object, type, args);</span>
        }

        /**
         * Remember the resolved constructor, because the code-generator will need it.
         */
<span class="fc" id="L502">        final IConstructor ctor = (IConstructor) ctors.get(0);</span>
<span class="fc" id="L503">        program.symbols.calls.put(object, ctor);</span>

<span class="fc" id="L505">        infer(object, (IExpressionType) type);</span>
<span class="fc" id="L506">    }</span>

    @Override
    public void visit(final CallMethodExpression object)
    {
        /**
         * Visit and type-check the owner expression.
         */
<span class="fc" id="L514">        object.getOwner().accept(this);</span>

<span class="fc" id="L516">        final IExpressionType type = program.symbols.expressions.get(object.getOwner());</span>

        // This will throw an exception, if the type is not a declared-type.
<span class="fc" id="L519">        program.checker.requireDeclaredType(object, type);</span>

        // This never fails.
<span class="fc" id="L522">        final IDeclaredType owner_type = (IDeclaredType) type;</span>

        /**
         * Visit and type-check the argument expressions.
         * At the same time, build a list containing the types of the arguments.
         */
<span class="fc" id="L528">        final List&lt;IExpressionType&gt; args = Lists.newLinkedList();</span>

<span class="fc bfc" id="L530" title="All 2 branches covered.">        for (IExpression arg : object.getArguments())</span>
        {
<span class="fc" id="L532">            arg.accept(this);</span>
<span class="fc" id="L533">            args.add(program.symbols.expressions.get(arg));</span>
<span class="fc" id="L534">        }</span>


        /**
         * Resolve the method.
         */
<span class="fc" id="L540">        final String name = object.getName().getName();</span>

<span class="fc" id="L542">        final List&lt;IMethod&gt; methods = program.typesystem.utils.resolveMethods(module.type,</span>
                                                                              owner_type,
                                                                              name,
                                                                              args);

        /**
         * If no acceptable method overload was found, issue an error.
         */
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (methods.isEmpty())</span>
        {
            // This will throw an exception.
<span class="pc" id="L553">            program.checker.reportNoSuchMethod(object,</span>
                                               false,
                                               owner_type,
<span class="fc" id="L556">                                               object.getName().getName(),</span>
                                               args);
        }

        /**
         * Remember the selected method overload, because the code-generator will need it.
         */
<span class="fc" id="L563">        final IMethod method = (IMethod) methods.get(0);</span>
<span class="fc" id="L564">        program.symbols.calls.put(object, method);</span>

        /**
         * The return-type of a call-expression is the return-type
         * of the selected method overload.
         */
<span class="fc" id="L570">        infer(object, method.getReturnType());</span>
<span class="fc" id="L571">    }</span>

    @Override
    public void visit(final SetFieldExpression object)
    {
        /**
         * Visit the owner expression.
         */
<span class="fc" id="L579">        object.getOwner().accept(this);</span>

        /**
         * Visit the value expression.
         */
<span class="fc" id="L584">        object.getValue().accept(this);</span>

        /**
         * Resolve the field.
         */
<span class="fc" id="L589">        final IField field = findField(object, object.getOwner(), object.getName().getName());</span>

        /**
         * Ensure that the field is not readonly.
         */
<span class="fc" id="L594">        program.checker.requireNonFinalFieldAssignment(object, field);</span>

        /**
         * Ensure that the value can actually be assigned to the field.
         */
<span class="fc" id="L599">        program.checker.checkAssign(object, field.getType(), object.getValue());</span>

        /**
         * The return-type of the expression is void.
         */
<span class="fc" id="L604">        infer(object, program.typesystem.utils.VOID);</span>
<span class="fc" id="L605">    }</span>

    @Override
    public void visit(final GetFieldExpression object)
    {
        /**
         * Visit the owner expression.
         */
<span class="fc" id="L613">        object.getOwner().accept(this);</span>

        /**
         * Resolve the field.
         */
<span class="fc" id="L618">        final IField field = findField(object, object.getOwner(), object.getName().getName());</span>

        /**
         * The return-type of the expression is the type of the field.
         */
<span class="fc" id="L623">        infer(object, field.getType());</span>
<span class="fc" id="L624">    }</span>

    @Override
    public void visit(final InstanceOfExpression object)
    {
        /**
         * Resolve the type.
         */
<span class="fc" id="L632">        final IDeclaredType type = module.imports.resolveDeclaredType(object.getType());</span>

        /**
         * Visit the value expression.
         */
<span class="fc" id="L637">        object.getValue().accept(this);</span>

        /**
         * Get the type of the value expression.
         */
<span class="fc" id="L642">        final IExpressionType value = program.symbols.expressions.get(object.getValue());</span>

        /**
         * The type of the value expression must be a declared-type.
         */
<span class="fc" id="L647">        program.checker.requireDeclaredType(object, value);</span>

        /**
         * The operation must be viable.
         */
<span class="fc" id="L652">        final boolean is_null = value.isNullType();</span>
<span class="fc" id="L653">        final boolean case1 = value.isSubtypeOf(type);</span>
<span class="fc" id="L654">        final boolean case2 = type.isSubtypeOf(value);</span>

<span class="pc bpc" id="L656" title="1 of 6 branches missed.">        if (is_null || !(case1 || case2))</span>
        {
            // This will throw an exception.
<span class="nc" id="L659">            program.checker.reportNonViableInstanceOf(object, value, type);</span>
        }

        /**
         * The return-type of an instance-of expression is boolean.
         */
<span class="fc" id="L665">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>
<span class="fc" id="L666">    }</span>

    @Override
    public void visit(final TernaryConditionalExpression object)
    {
        /**
         * Visit ant type-check the condition expression.
         */
<span class="fc" id="L674">        object.getCondition().accept(this);</span>

<span class="fc" id="L676">        program.checker.checkCondition(object.getCondition());</span>

        /**
         * Visit and type-check the true-case expression.
         */
<span class="fc" id="L681">        object.getCaseTrue().accept(this);</span>

        // The true-case expression must produce a value.
<span class="fc" id="L684">        program.checker.requireArguments(Collections.singleton(object.getCaseTrue()));</span>

        /**
         * Visit and type-check the false-case expression.
         */
<span class="fc" id="L689">        object.getCaseFalse().accept(this);</span>

        // The false-case expression must produce a value.
<span class="fc" id="L692">        program.checker.requireArguments(Collections.singleton(object.getCaseFalse()));</span>

        /**
         * The operands must be compatible.
         */
<span class="fc" id="L697">        final IExpressionType left = program.symbols.expressions.get(object.getCaseTrue());</span>
<span class="fc" id="L698">        final IExpressionType right = program.symbols.expressions.get(object.getCaseFalse());</span>

        // The type of one of the operands should be wider than the other.
        // For example:
        //     (if Boolean then String else Object) ==&gt; Object is Wider
        //     (if Boolean then Object else String) ==&gt; Object is Wider
        // Error Case Example:
        //     (if Boolean then Integer else Long) ==&gt; Neither operand is wider than the other.
        // In the error case, this variable will be assigned null.
<span class="fc" id="L707">        final IExpressionType widest = program.typesystem.utils.widestType(left, right);</span>

        /**
         * If neither operand is wider, then issue an error.
         */
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (widest == null)</span>
        {
            // This will throw an exception.
<span class="nc" id="L715">            program.checker.reportIncompatibleOperands(object, left, right);</span>
        }

        /**
         * The return-type is the ternary-conditional-expression is the widest operand type.
         */
<span class="fc" id="L721">        infer(object, widest);</span>
<span class="fc" id="L722">    }</span>

    @Override
    public void visit(final LocalsExpression object)
    {
        /**
         * Get the names of the variables that will be captured.
         */
<span class="fc" id="L730">        final Set&lt;String&gt; visible = Sets.newTreeSet();</span>

<span class="fc bfc" id="L732" title="All 2 branches covered.">        for (String variable : allocator.getVariables())</span>
        {
            // The variable must be in-scope.
<span class="fc" id="L735">            final boolean usable = allocator.isUsable(variable);</span>

            // The variable cannot be a temporary.
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">            final boolean non_temp = !allocator.isTemporary(variable);</span>

<span class="pc bpc" id="L740" title="1 of 4 branches missed.">            if (usable &amp;&amp; non_temp)</span>
            {
<span class="fc" id="L742">                visible.add(variable);</span>
            }
<span class="fc" id="L744">        }</span>

        /**
         * The code-generator will needs the names of the variables to capture.
         */
<span class="fc" id="L749">        program.symbols.locals.put(object, visible);</span>

        /**
         * The return-type of a locals-expression is always LocalsMap.
         */
<span class="fc" id="L754">        infer(object, program.typesystem.utils.LOCALS_MAP);</span>
<span class="fc" id="L755">    }</span>

    @Override
    public void visit(final OnceExpression object)
    {
        /**
         * Visit and type-check the expression that produces the value to memoize.
         */
<span class="fc" id="L763">        object.getValue().accept(this);</span>

<span class="fc" id="L765">        program.checker.requireReferenceType(object.getValue());</span>
<span class="fc" id="L766">        program.checker.requireNonNull(object.getValue());</span>

        /**
         * The return-type of a once-expression is the type of the memoized value.
         */
<span class="fc" id="L771">        infer(object, program.symbols.expressions.get(object.getValue()));</span>
<span class="fc" id="L772">    }</span>

    @Override
    public void visit(final AsOperation object)
    {
        // Visit the operand.
<span class="fc" id="L778">        object.getValue().accept(this);</span>

        // Get the type of the operand.
<span class="fc" id="L781">        final IExpressionType input = program.symbols.expressions.get(object.getValue());</span>

        // Get the output type.
<span class="fc" id="L784">        final IReturnType output = module.imports.resolveReturnType(object.getType());</span>

        // Obtain a description of the conversion being performed.
        // This will be null, if the conversion is impossible.
<span class="fc" id="L788">        final Conversion conversion = Conversion.findConversion(program.typesystem, input, output);</span>

        /**
         * If the conversion is impossible, issue an error.
         */
<span class="fc bfc" id="L793" title="All 2 branches covered.">        if (conversion == null)</span>
        {
            // This call will throw an exception.
<span class="nc" id="L796">            program.checker.reportNoSuchAsConversion(object, output);</span>
        }

        // Remember the conversion, because the code-generator will need it.
<span class="fc" id="L800">        program.symbols.conversions.put(object, conversion);</span>

        // A conversion operation returns the return-type of the operation.
<span class="fc" id="L803">        infer(object, output);</span>
<span class="fc" id="L804">    }</span>

    @Override
    public void visit(final IsOperation object)
    {
        // Visit the operand.
<span class="fc" id="L810">        object.getValue().accept(this);</span>

        // Get the type of the operand.
<span class="fc" id="L813">        final IExpressionType input = program.symbols.expressions.get(object.getValue());</span>

        // Get the output type.
<span class="fc" id="L816">        final IReturnType output = module.imports.resolveReturnType(object.getType());</span>

        // Obtain a description of the conversion being performed.
        // This will be null, if the conversion is impossible.
<span class="fc" id="L820">        final Conversion conversion = Conversion.findConversion(program.typesystem, input, output);</span>

        /**
         * If the conversion is impossible, issue an error.
         */
<span class="fc bfc" id="L825" title="All 2 branches covered.">        if (conversion == null)</span>
        {
            // This call will throw an exception.
<span class="nc" id="L828">            program.checker.reportNoSuchIsConversion(object, output);</span>
        }

        // Remember the conversion, because the code-generator will need it.
<span class="fc" id="L832">        program.symbols.conversions.put(object, conversion);</span>

        // A conversion operation returns the return-type of the operation.
<span class="fc" id="L835">        infer(object, output);</span>
<span class="fc" id="L836">    }</span>

    @Override
    public void visit(final NegateOperation object)
    {
        // Visit the operand and perform type-checking.
<span class="fc" id="L842">        unaryOperation(object,</span>
                       &quot;negate&quot;,
<span class="fc" id="L844">                       object.getOperand());</span>
<span class="fc" id="L845">    }</span>

    @Override
    public void visit(final NotOperation object)
    {
        // Visit the operand and perform type-checking.
<span class="fc" id="L851">        unaryOperation(object,</span>
                       &quot;not&quot;,
<span class="fc" id="L853">                       object.getOperand());</span>
<span class="fc" id="L854">    }</span>

    @Override
    public void visit(final DivideOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L860">        binaryOperation(object,</span>
                        &quot;divide&quot;,
<span class="fc" id="L862">                        object.getLeftOperand(),</span>
<span class="fc" id="L863">                        object.getRightOperand());</span>
<span class="fc" id="L864">    }</span>

    @Override
    public void visit(final ModuloOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L870">        binaryOperation(object,</span>
                        &quot;modulo&quot;,
<span class="fc" id="L872">                        object.getLeftOperand(),</span>
<span class="fc" id="L873">                        object.getRightOperand());</span>
<span class="fc" id="L874">    }</span>

    @Override
    public void visit(final MultiplyOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L880">        binaryOperation(object,</span>
                        &quot;multiply&quot;,
<span class="fc" id="L882">                        object.getLeftOperand(),</span>
<span class="fc" id="L883">                        object.getRightOperand());</span>
<span class="fc" id="L884">    }</span>

    @Override
    public void visit(final AddOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L890">        binaryOperation(object,</span>
                        &quot;add&quot;,
<span class="fc" id="L892">                        object.getLeftOperand(),</span>
<span class="fc" id="L893">                        object.getRightOperand());</span>
<span class="fc" id="L894">    }</span>

    @Override
    public void visit(final SubtractOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L900">        binaryOperation(object,</span>
                        &quot;subtract&quot;,
<span class="fc" id="L902">                        object.getLeftOperand(),</span>
<span class="fc" id="L903">                        object.getRightOperand());</span>
<span class="fc" id="L904">    }</span>

    @Override
    public void visit(final ConcatOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L910">        binaryOperation(object,</span>
                        &quot;concat&quot;,
<span class="fc" id="L912">                        object.getLeftOperand(),</span>
<span class="fc" id="L913">                        object.getRightOperand());</span>
<span class="fc" id="L914">    }</span>

    @Override
    public void visit(final LessThanOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L920">        binaryOperation(object,</span>
                        &quot;lessThan&quot;,
<span class="fc" id="L922">                        object.getLeftOperand(),</span>
<span class="fc" id="L923">                        object.getRightOperand());</span>
<span class="fc" id="L924">    }</span>

    @Override
    public void visit(final LessThanOrEqualsOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L930">        binaryOperation(object,</span>
                        &quot;lessThanOrEquals&quot;,
<span class="fc" id="L932">                        object.getLeftOperand(),</span>
<span class="fc" id="L933">                        object.getRightOperand());</span>
<span class="fc" id="L934">    }</span>

    @Override
    public void visit(final GreaterThanOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L940">        binaryOperation(object,</span>
                        &quot;greaterThan&quot;,
<span class="fc" id="L942">                        object.getLeftOperand(),</span>
<span class="fc" id="L943">                        object.getRightOperand());</span>
<span class="fc" id="L944">    }</span>

    @Override
    public void visit(final GreaterThanOrEqualsOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L950">        binaryOperation(object,</span>
                        &quot;greaterThanOrEquals&quot;,
<span class="fc" id="L952">                        object.getLeftOperand(),</span>
<span class="fc" id="L953">                        object.getRightOperand());</span>
<span class="fc" id="L954">    }</span>

    @Override
    public void visit(final EqualsOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L960">        binaryOperation(object,</span>
                        &quot;equals&quot;,
<span class="fc" id="L962">                        object.getLeftOperand(),</span>
<span class="fc" id="L963">                        object.getRightOperand());</span>
<span class="fc" id="L964">    }</span>

    @Override
    public void visit(final NotEqualsOperation object)
    {
        // Visit the operands and perform type-checking.
<span class="fc" id="L970">        binaryOperation(object,</span>
                        &quot;notEquals&quot;,
<span class="fc" id="L972">                        object.getLeftOperand(),</span>
<span class="fc" id="L973">                        object.getRightOperand());</span>
<span class="fc" id="L974">    }</span>

    @Override
    public void visit(final IdentityEqualsOperation object)
    {
        // Visit the operands.
<span class="fc" id="L980">        object.getLeftOperand().accept(this);</span>
<span class="fc" id="L981">        object.getRightOperand().accept(this);</span>

        // Perform type-checking.
<span class="fc" id="L984">        program.checker.requireReferenceType(object.getLeftOperand());</span>
<span class="fc" id="L985">        program.checker.requireReferenceType(object.getRightOperand());</span>

        // This type of operator always returns boolean.
<span class="fc" id="L988">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>

        // Remember the method that is needed to implement this operator.
<span class="fc" id="L991">        program.symbols.calls.put(object, IDENTITY_EQUALITY);</span>
<span class="fc" id="L992">    }</span>

    @Override
    public void visit(final IdentityNotEqualsOperation object)
    {
        // Visit the operands.
<span class="fc" id="L998">        object.getLeftOperand().accept(this);</span>
<span class="fc" id="L999">        object.getRightOperand().accept(this);</span>

        // Perform type-checking.
<span class="fc" id="L1002">        program.checker.requireReferenceType(object.getLeftOperand());</span>
<span class="fc" id="L1003">        program.checker.requireReferenceType(object.getRightOperand());</span>

        // This type of operator always returns boolean.
<span class="fc" id="L1006">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>

        // Remember the method that is needed to implement this operator.
<span class="fc" id="L1009">        program.symbols.calls.put(object, IDENTITY_INEQUALITY);</span>
<span class="fc" id="L1010">    }</span>

    @Override
    public void visit(final AndOperation object)
    {
        // Visit and type-check the operands.
<span class="fc" id="L1016">        condition(object.getLeftOperand());</span>
<span class="fc" id="L1017">        condition(object.getRightOperand());</span>

        // This type of operator always returns a boolean value.
<span class="fc" id="L1020">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>
<span class="fc" id="L1021">    }</span>

    @Override
    public void visit(final OrOperation object)
    {
        // Visit and type-check the operands.
<span class="fc" id="L1027">        condition(object.getLeftOperand());</span>
<span class="fc" id="L1028">        condition(object.getRightOperand());</span>

        // This type of operator always returns a boolean value.
<span class="fc" id="L1031">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>
<span class="fc" id="L1032">    }</span>

    @Override
    public void visit(final XorOperation object)
    {
        // Visit and type-check the operands.
<span class="fc" id="L1038">        condition(object.getLeftOperand());</span>
<span class="fc" id="L1039">        condition(object.getRightOperand());</span>

        // This type of operator always returns a boolean value.
<span class="fc" id="L1042">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>
<span class="fc" id="L1043">    }</span>

    @Override
    public void visit(final ImpliesOperation object)
    {
        // Visit and type-check the operands.
<span class="fc" id="L1049">        condition(object.getLeftOperand());</span>
<span class="fc" id="L1050">        condition(object.getRightOperand());</span>

        // This type of operator always returns a boolean value.
<span class="fc" id="L1053">        infer(object, program.typesystem.utils.PRIMITIVE_BOOLEAN);</span>
<span class="fc" id="L1054">    }</span>

    @Override
    public void visit(final NullCoalescingOperation object)
    {
        // Visit the operands.
<span class="fc" id="L1060">        object.getLeftOperand().accept(this);</span>
<span class="fc" id="L1061">        object.getRightOperand().accept(this);</span>

        // Retrieve the types of the operands.
<span class="fc" id="L1064">        final IExpressionType left = program.symbols.expressions.get(object.getLeftOperand());</span>
<span class="fc" id="L1065">        final IExpressionType right = program.symbols.expressions.get(object.getRightOperand());</span>

        // Noth operands must be references.
<span class="fc" id="L1068">        program.checker.requireReferenceType(object.getLeftOperand());</span>
<span class="fc" id="L1069">        program.checker.requireReferenceType(object.getRightOperand());</span>

        // The type of one of the operands should be wider than the other.
        // For example:
        //     (String ?? Object) ==&gt; Object is Wider
        //     (Object ?? String) ==&gt; Object is Wider
        // Error Case Example:
        //     (Integer ?? Long) ==&gt; Neither operand is wider than the other.
        // In the error case, this variable will be assigned null.
<span class="fc" id="L1078">        final IExpressionType widest = program.typesystem.utils.widestType(left, right);</span>

        // If neither operand is wider, then issue an error.
<span class="fc bfc" id="L1081" title="All 2 branches covered.">        if (widest == null)</span>
        {
<span class="nc" id="L1083">            program.checker.reportIncompatibleOperands(object, left, right);</span>
        }

        // A null-coalescing operator returns the widest of its operand types.
<span class="fc" id="L1087">        infer(object, left);</span>
<span class="fc" id="L1088">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>