<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractStructTupleCompiler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.compilers</a> &gt; <span class="el_source">AbstractStructTupleCompiler.java</span></div><h1>AbstractStructTupleCompiler.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.compilers;

import autumn.lang.compiler.ClassFile;
import autumn.lang.compiler.ast.commons.IRecord;
import autumn.lang.internals.Helpers;
import com.google.common.collect.Lists;
import com.mackenziehigh.autumn.lang.compiler.typesystem.CustomConstructor;
import com.mackenziehigh.autumn.lang.compiler.typesystem.CustomFormalParameter;
import com.mackenziehigh.autumn.lang.compiler.typesystem.CustomMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IConstructor;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IFormalParameter;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IInterfaceType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IVariableType;
import com.mackenziehigh.autumn.lang.compiler.utils.BridgeMethod;
import com.mackenziehigh.autumn.lang.compiler.utils.GetterMethod;
import com.mackenziehigh.autumn.lang.compiler.utils.RecordElement;
import com.mackenziehigh.autumn.lang.compiler.utils.SetterMethod;
import com.mackenziehigh.autumn.lang.compiler.utils.TypeSystemUtils;
import com.mackenziehigh.autumn.lang.compiler.utils.Utils;
import java.util.LinkedList;
import java.util.List;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TableSwitchInsnNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

/**
 * This class generalizes the compilation of struct-definitions and tuple-definitions.
 *
 * &lt;p&gt;
 * Note: Design-definitions are technically records, but they are compiled very differently.
 * &lt;/p&gt;
 *
 * @author Mackenzie High
 */
<span class="fc" id="L47">class AbstractStructTupleCompiler</span>
        extends AbstractRecordCompiler
{
    /**
     * This is the type of the tuple's only constructor.
     */
    private CustomConstructor ctor;

    /**
     * This flag is true, iff the record is a struct.
     */
    private final boolean struct;

    /**
     * Sole Constructor.
     *
     * @param module is the module that contains the tuple being compiled.
     * @param node is the AST node that represents the tuple being compiled.
     */
    public AbstractStructTupleCompiler(final ModuleCompiler module,
                                       final IRecord node,
                                       final boolean is_tuple)
    {
<span class="fc" id="L70">        super(module, node);</span>

<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        assert module != null;</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        assert node != null;</span>

<span class="fc bfc" id="L75" title="All 2 branches covered.">        this.struct = !is_tuple;</span>
<span class="fc" id="L76">    }</span>

    /**
     * This method gets the name of a field that stores an element.
     *
     * &lt;p&gt;
     * This method is needed in order to prevent name collisions with special fields.
     * &lt;/p&gt;
     *
     * @param element is the name of the element.
     * @return the name of the field that stores the value of the element.
     */
    private String nameOfField(final String element)
    {
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        assert element != null;</span>

<span class="fc" id="L92">        return &quot;element$&quot; + element;</span>
    }

    /**
     * This method generates the compiled class-file.
     *
     * @return the compiled class-file.
     */
    public ClassFile build()
    {
<span class="fc" id="L102">        final String internal_name = Utils.internalName(type);</span>

<span class="fc" id="L104">        final String source_name = Utils.sourceName(type);</span>

        /**
         * Create the bytecode representations of the tuple's fields.
         */
<span class="fc" id="L109">        final List&lt;FieldNode&gt; fields = Lists.newLinkedList();</span>

        // Create the field that stores the names of the elements.
<span class="fc" id="L112">        fields.add(new FieldNode(Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC + Opcodes.ACC_FINAL,</span>
                                 &quot;KEYS&quot;,
                                 &quot;Ljava/util/List;&quot;,
                                 null,
                                 null));

        // Create the field that stores the types of the elements.
<span class="fc" id="L119">        fields.add(new FieldNode(Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC + Opcodes.ACC_FINAL,</span>
                                 &quot;TYPES&quot;,
                                 &quot;Ljava/util/List;&quot;,
                                 null,
                                 null));

        // Create the field that stores the instance() tuple.
<span class="fc" id="L126">        fields.add(new FieldNode(Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC + Opcodes.ACC_FINAL,</span>
                                 &quot;INSTANCE&quot;,
<span class="fc" id="L128">                                 type.getDescriptor(),</span>
                                 null,
                                 null));

        // Create the fields that store the values of the elements.
<span class="fc" id="L133">        fields.addAll(this.generateElementFields());</span>

        /**
         * Create the bytecode representation of the tuple itself.
         */
<span class="fc" id="L138">        final ClassNode clazz = new ClassNode();</span>
        {
<span class="fc" id="L140">            clazz.version = Opcodes.V1_6;</span>
<span class="fc" id="L141">            clazz.visibleAnnotations = module.anno_utils.compileAnnotationList(type.getAnnotations());</span>
<span class="fc" id="L142">            clazz.access = type.getModifiers();</span>
<span class="fc" id="L143">            clazz.name = internal_name;</span>
<span class="fc" id="L144">            clazz.superName = Utils.internalName(type.getSuperclass());</span>
<span class="fc" id="L145">            clazz.fields = fields;</span>
<span class="fc" id="L146">            clazz.methods = Lists.newLinkedList();</span>
<span class="fc" id="L147">            clazz.sourceFile = String.valueOf(node.getLocation().getFile());</span>

            /**
             * The record may implement zero or more designs, as specified by the user.
             */
<span class="fc bfc" id="L152" title="All 2 branches covered.">            for (IInterfaceType superinterface : type.getSuperinterfaces())</span>
            {
<span class="fc" id="L154">                clazz.interfaces.add(Utils.internalName(superinterface));</span>
<span class="fc" id="L155">            }</span>

            /**
             * Add some special methods to the tuple.
             */
<span class="fc" id="L160">            clazz.methods.add(this.generateStaticCtor());</span>

<span class="fc" id="L162">            clazz.methods.add(this.generateCtor());</span>

<span class="fc" id="L164">            clazz.methods.add(this.generateMethodInstance());</span>

<span class="fc" id="L166">            clazz.methods.add(this.generateMethodIsStruct());</span>

<span class="fc" id="L168">            clazz.methods.add(this.generateMethodIsTuple());</span>

<span class="fc" id="L170">            clazz.methods.add(this.generateMethodKeys());</span>

<span class="fc" id="L172">            clazz.methods.add(this.generateMethodTypes());</span>

<span class="fc" id="L174">            clazz.methods.add(this.generateMethodGet());</span>

<span class="fc" id="L176">            clazz.methods.add(this.generateMethodSet());</span>

<span class="fc" id="L178">            clazz.methods.addAll(this.generateBridgeMethods());</span>

            /**
             * Generate the setter and getter methods.
             */
<span class="fc bfc" id="L183" title="All 2 branches covered.">            for (RecordElement element : analyzer.elements.values())</span>
            {
                /**
                 * Generate the primary setter and primary getter methods.
                 * In other words, generate the methods that can actually set or get an element.
                 */
<span class="fc" id="L189">                clazz.methods.add(this.generateSetter(element.setter()));</span>
<span class="fc" id="L190">                clazz.methods.add(this.generateGetter(element.getter()));</span>
<span class="fc" id="L191">            }</span>
        }

//        for (IMethod m : type.getAllVisibleMethods())
//        {
//            System.out.println(m.getNamePlusDescriptor() + &quot; in &quot; + m.getOwner().getDescriptor());
//        }

        /**
         * Assemble the bytecode into an array of bytes.
         */
<span class="fc" id="L202">        final ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS);</span>
<span class="fc" id="L203">        clazz.accept(writer);</span>
<span class="fc" id="L204">        final byte[] bytecode = writer.toByteArray();</span>

        /**
         * Create the class-file object that will store the emitted bytecode.
         */
<span class="fc" id="L209">        final ClassFile file = new ClassFile(source_name, bytecode);</span>

<span class="fc" id="L211">        return file;</span>
    }

    /**
     * This method creates the type-system representation of the only constructor in the tuple.
     *
     * @return the aforedescribed constructor.
     */
    @Override
    protected IConstructor typeofCtor()
    {
<span class="fc" id="L222">        final List&lt;IFormalParameter&gt; formals = Lists.newLinkedList();</span>

        /**
         * Create a formal parameter for each element in the tuple.
         */
<span class="fc bfc" id="L227" title="All 2 branches covered.">        for (String element : keys)</span>
        {
<span class="fc" id="L229">            final CustomFormalParameter formal = new CustomFormalParameter();</span>

<span class="fc" id="L231">            formal.setType(typeOfElement(element));</span>

<span class="fc" id="L233">            formals.add(formal);</span>
<span class="fc" id="L234">        }</span>

<span class="fc" id="L236">        ctor = new CustomConstructor(program.typesystem.typefactory());</span>

<span class="fc" id="L238">        ctor.setAnnotations(new LinkedList());</span>
<span class="fc" id="L239">        ctor.setModifiers(Opcodes.ACC_PUBLIC);</span>
<span class="fc" id="L240">        ctor.setOwner(type);</span>
<span class="fc" id="L241">        ctor.setParameters(formals);</span>
<span class="fc" id="L242">        ctor.setReturnType(program.typesystem.utils.VOID);</span>
<span class="fc" id="L243">        ctor.setThrowsClause(new LinkedList());</span>

<span class="fc" id="L245">        return ctor;</span>
    }

    /**
     * This method creates the type-system representation of the instance() method.
     *
     * @return the aforedescribed method.
     */
    @Override
    protected IMethod typeofInstance()
    {
<span class="fc" id="L256">        final CustomMethod method = new CustomMethod(program.typesystem.typefactory(), false);</span>

<span class="fc" id="L258">        method.setAnnotations(new LinkedList());</span>
<span class="fc" id="L259">        method.setModifiers(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC);</span>
<span class="fc" id="L260">        method.setName(&quot;instance&quot;);</span>
<span class="fc" id="L261">        method.setOwner(type);</span>
<span class="fc" id="L262">        method.setParameters(new LinkedList());</span>
<span class="fc" id="L263">        method.setReturnType(type);</span>
<span class="fc" id="L264">        method.setThrowsClause(new LinkedList());</span>

<span class="fc" id="L266">        return method;</span>
    }

    /**
     * This method generates the bytecode representations of the fields that store the elements.
     *
     * @return the generated bytecode.
     */
    private List&lt;FieldNode&gt; generateElementFields()
    {
<span class="fc" id="L276">        final List&lt;FieldNode&gt; fields = Lists.newLinkedList();</span>

        /**
         * Generate one field for each element.
         */
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (String element : keys)</span>
        {
            // The field is private, because element's are accessed via getters and setters.
<span class="fc" id="L284">            final int access = Opcodes.ACC_PRIVATE;</span>

            // The name of the field will be given a prefix.
            // This prevents name collisions with special fields.
<span class="fc" id="L288">            final String name = nameOfField(element);</span>

            // The descriptor describes the static-type of the element.
<span class="fc" id="L291">            final String desc = typeOfElement(element).getDescriptor();</span>

            // Create the bytecode representation of the field.
<span class="fc" id="L294">            final FieldNode field = new FieldNode(access, name, desc, null, null);</span>

<span class="fc" id="L296">            fields.add(field);</span>
<span class="fc" id="L297">        }</span>

<span class="fc" id="L299">        return fields;</span>
    }

    /**
     * This method generates the bytecode representation of the tuple's only constructor.
     *
     * &lt;p&gt;
     * The constructor's actual parameters are the values of the tuple's elements.
     * Parameter[i] of the constructor provides the value of element[i] of the tuple.
     * &lt;/p&gt;
     *
     * @return the aforedescribed bytecode.
     */
    private MethodNode generateCtor()
    {
        // The generated constructor must do the following:
        // . invoke super()
        // . for each parameter [p]:
        // . . transfer [p] into the field that will store [p].
        // . return
        //
        //////////////////////////////////////////////////////////

<span class="fc" id="L322">        final MethodNode method = Utils.bytecodeOf(module, ctor);</span>

        /**
         * Generate the bytecode that invokes super().
         */
<span class="fc" id="L327">        method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 0)); // Load 'this'</span>
<span class="fc" id="L328">        method.instructions.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
<span class="fc" id="L329">                                                   Utils.internalName(program.typesystem.utils.ABSTRACT_RECORD),</span>
                                                   &quot;&lt;init&gt;&quot;,
                                                   &quot;()V&quot;));


        /**
         * Skip the first memory address (i.e. address zero),
         * because that is where 'this' is automatically stored.
         */
<span class="fc" id="L338">        int address = 1;</span>

        /**
         * Transfer each actual parameter into the field that stores the related element.
         */
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (String element : keys)</span>
        {
<span class="fc" id="L345">            final IVariableType element_type = typeOfElement(element);</span>

<span class="fc" id="L347">            final String owner = Utils.internalName(type);</span>
<span class="fc" id="L348">            final String name = nameOfField(element);</span>
<span class="fc" id="L349">            final String desc = element_type.getDescriptor();</span>

<span class="fc" id="L351">            method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 0)); // Load 'this'</span>
<span class="fc" id="L352">            method.instructions.add(Utils.selectLoadVarInsn(element_type, address));</span>
<span class="fc" id="L353">            method.instructions.add(new FieldInsnNode(Opcodes.PUTFIELD, owner, name, desc));</span>

<span class="fc" id="L355">            address += Utils.sizeof(element_type);</span>
<span class="fc" id="L356">        }</span>

        /**
         * Return from the constructor.
         */
<span class="fc" id="L361">        method.instructions.add(new InsnNode(Opcodes.RETURN));</span>

<span class="fc" id="L363">        return method;</span>
    }

    /**
     * This method generates the tuple's static constructor.
     *
     * &lt;p&gt;
     * The static-constructor is needed in order to initialize a few static fields.
     * &lt;/p&gt;
     *
     * @return the generated method.
     */
    private MethodNode generateStaticCtor()
    {
<span class="fc" id="L377">        final MethodNode clinit = new MethodNode(Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC,</span>
                                                 &quot;&lt;clinit&gt;&quot;,
                                                 &quot;()V&quot;,
                                                 null,
                                                 new String[0]);

        /**
         * Initialize the KEYS field.
         */
<span class="fc" id="L386">        initListOfKeys(clinit.instructions);</span>

        /**
         * Initialize the TYPES field.
         */
<span class="fc" id="L391">        initListOfTypes(clinit.instructions);</span>

        /**
         * Initialize the INSTANCE field.
         */
<span class="fc" id="L396">        initInstance(clinit.instructions);</span>

        /**
         * Exit the static constructor.
         */
<span class="fc" id="L401">        clinit.instructions.add(new InsnNode(Opcodes.RETURN));</span>

<span class="fc" id="L403">        return clinit;</span>
    }

    /**
     * This method generates bytecode that initializes the field that stores the list of keys.
     *
     * @param code is the bytecode being generated.
     */
    private void initListOfKeys(final InsnList code)
    {
<span class="fc" id="L413">        final CollectionCompiler&lt;String&gt; cmp = new CollectionCompiler&lt;String&gt;()</span>
<span class="fc" id="L414">        {</span>
            @Override
            public void compile(final String element)
            {
<span class="fc" id="L418">                code().add(new LdcInsnNode(element));</span>
<span class="fc" id="L419">            }</span>

            @Override
            public InsnList code()
            {
<span class="fc" id="L424">                return code;</span>
            }
        };

        /**
         * Generate the bytecode that creates a mutable list containing the keys.
         */
<span class="fc" id="L431">        cmp.compile(keys);</span>

        /**
         * Make the list immutable.
         */
<span class="fc" id="L436">        Utils.makeListImmutable(code);</span>

        /**
         * Assign the immutable list to the field.
         */
<span class="fc" id="L441">        code.add(new FieldInsnNode(Opcodes.PUTSTATIC,</span>
<span class="fc" id="L442">                                   Utils.internalName(type),</span>
                                   &quot;KEYS&quot;,
                                   &quot;Ljava/util/List;&quot;));
<span class="fc" id="L445">    }</span>

    /**
     * This method generates bytecode that initializes the field that stores the map of types.
     *
     * @param code is the bytecode being generated.
     */
    private void initListOfTypes(final InsnList code)
    {
<span class="fc" id="L454">        final CollectionCompiler&lt;String&gt; cmp = new CollectionCompiler&lt;String&gt;()</span>
<span class="fc" id="L455">        {</span>
            @Override
            public void compile(final String element)
            {
<span class="fc" id="L459">                code().add(Utils.ldcClass(typeOfElement(element)));</span>
<span class="fc" id="L460">            }</span>

            @Override
            public InsnList code()
            {
<span class="fc" id="L465">                return code;</span>
            }
        };

        /**
         * Generate the bytecode that creates a mutable list containing the keys.
         */
<span class="fc" id="L472">        cmp.compile(keys);</span>

        /**
         * Make the list immutable.
         */
<span class="fc" id="L477">        Utils.makeListImmutable(code);</span>

        /**
         * Assign the immutable list to the field.
         */
<span class="fc" id="L482">        code.add(new FieldInsnNode(Opcodes.PUTSTATIC,</span>
<span class="fc" id="L483">                                   Utils.internalName(type),</span>
                                   &quot;TYPES&quot;,
                                   &quot;Ljava/util/List;&quot;));
<span class="fc" id="L486">    }</span>

    /**
     * This method generates bytecode that initializes the field containing instance() tuple.
     *
     * @param code is the bytecode being generated.
     */
    private void initInstance(final InsnList code)
    {
        /**
         * Create a new uninitialized instance of the tuple.
         */
<span class="fc" id="L498">        code.add(new TypeInsnNode(Opcodes.NEW, Utils.internalName(type)));</span>

        /**
         * Duplicate the object-reference.
         */
<span class="fc" id="L503">        code.add(new InsnNode(Opcodes.DUP));</span>

        /**
         * Load the value of each element onto the operand-stack.
         */
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (String element : keys)</span>
        {
            /**
             * Load the default value of the element onto the operand-stack.
             */
<span class="fc" id="L513">            code.add(Utils.ldcDefault(typeOfElement(element)));</span>
<span class="fc" id="L514">        }</span>

        /**
         * Invoke the constructor in order to create a copy of this object.
         */
<span class="fc" id="L519">        code.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
<span class="fc" id="L520">                                    Utils.internalName(type),</span>
                                    &quot;&lt;init&gt;&quot;,
<span class="fc" id="L522">                                    ctor.getDescriptor()));</span>

        /**
         * Assign the immutable list to the field.
         */
<span class="fc" id="L527">        code.add(new FieldInsnNode(Opcodes.PUTSTATIC,</span>
<span class="fc" id="L528">                                   Utils.internalName(type),</span>
                                   &quot;INSTANCE&quot;,
<span class="fc" id="L530">                                   type.getDescriptor()));</span>
<span class="fc" id="L531">    }</span>

    /**
     * This method generates the bytecode representations of the bridge methods.
     *
     * @return the generated methods.
     */
    private List&lt;MethodNode&gt; generateBridgeMethods()
    {
<span class="fc" id="L540">        final List&lt;MethodNode&gt; result = Lists.newLinkedList();</span>

        /**
         * Generate the bridge methods related to predefined methods.
         */
<span class="fc bfc" id="L545" title="All 2 branches covered.">        for (BridgeMethod bridge : special_bridges)</span>
        {
<span class="fc" id="L547">            result.add(bridge.compile(module));</span>
<span class="fc" id="L548">        }</span>

        /**
         * Generate the bridge methods related to elements.
         */
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (RecordElement element : analyzer.elements().values())</span>
        {
            /**
             * Generate the bridge getter methods.
             */
<span class="fc bfc" id="L558" title="All 2 branches covered.">            for (GetterMethod getter : element.bridgeGetters())</span>
            {
<span class="fc" id="L560">                final BridgeMethod bridge = new BridgeMethod(getter.findSelf(),</span>
<span class="fc" id="L561">                                                             getter.findBridgeTarget());</span>

<span class="fc" id="L563">                result.add(bridge.compile(module));</span>
<span class="fc" id="L564">            }</span>

            /**
             * Generate the bridge setter methods.
             */
<span class="fc bfc" id="L569" title="All 2 branches covered.">            for (SetterMethod setter : element.bridgeSetters())</span>
            {
<span class="fc" id="L571">                final BridgeMethod bridge = new BridgeMethod(setter.findSelf(),</span>
<span class="fc" id="L572">                                                             setter.findBridgeTarget());</span>

<span class="fc" id="L574">                result.add(bridge.compile(module));</span>
<span class="fc" id="L575">            }</span>
<span class="fc" id="L576">        }</span>

<span class="fc" id="L578">        return result;</span>
    }

    /**
     * This method generates the bytecode representation of the instance() method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodInstance()
    {
<span class="fc" id="L588">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L589">                                                   TypeSystemUtils.find(type.getMethods(),</span>
                                                                        &quot;instance&quot;,
<span class="fc" id="L591">                                                                        &quot;()&quot; + type.getDescriptor()));</span>

        // Remove the abstract modifier.
<span class="fc" id="L594">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        /**
         * The method simply retrieves the value in a static field and returns it.
         */
<span class="fc" id="L599">        method.instructions.add(new FieldInsnNode(Opcodes.GETSTATIC,</span>
<span class="fc" id="L600">                                                  Utils.internalName(type),</span>
                                                  &quot;INSTANCE&quot;,
<span class="fc" id="L602">                                                  type.getDescriptor()));</span>

<span class="fc" id="L604">        method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>

<span class="fc" id="L606">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of the isStruct() method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodIsStruct()
    {
<span class="fc" id="L616">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L617">                                                   TypeSystemUtils.find(type.getAllVisibleMethods(),</span>
                                                                        &quot;isStruct&quot;,
                                                                        &quot;()Z&quot;));

        // Remove the abstract modifier.
<span class="fc" id="L622">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        // Return a constant boolean value.
<span class="fc" id="L625">        method.instructions.add(new LdcInsnNode(struct));</span>
<span class="fc" id="L626">        method.instructions.add(new InsnNode(Opcodes.IRETURN));</span>

<span class="fc" id="L628">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of the isTuple() method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodIsTuple()
    {
<span class="fc" id="L638">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L639">                                                   TypeSystemUtils.find(type.getAllVisibleMethods(),</span>
                                                                        &quot;isTuple&quot;,
                                                                        &quot;()Z&quot;));

        // Remove the abstract modifier.
<span class="fc" id="L644">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        // Return a constant boolean value.
<span class="fc bfc" id="L647" title="All 2 branches covered.">        method.instructions.add(new LdcInsnNode(!struct));</span>
<span class="fc" id="L648">        method.instructions.add(new InsnNode(Opcodes.IRETURN));</span>

<span class="fc" id="L650">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of the set(int, Object) method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodSet()
    {
<span class="fc" id="L660">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L661">                                                   TypeSystemUtils.find(type.getAllVisibleMethods(),</span>
                                                                        &quot;set&quot;,
<span class="fc" id="L663">                                                                        &quot;(ILjava/lang/Object;)&quot; + program.typesystem.utils.RECORD.getDescriptor()));</span>

        // Remove the abstract modifier.
<span class="fc" id="L666">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

<span class="fc" id="L668">        final LabelNode default_case = new LabelNode();</span>

        /**
         * Essentially, this will generate a switch-statement.
         * The switch-case branches based on the index that is given as an parameter to the method.
         * The default-case will be generated at the bottom of this method,.
         * because no jump-table is needed, if the tuple is empty.
         */
<span class="fc bfc" id="L676" title="All 2 branches covered.">        if (!keys.isEmpty())</span>
        {
            /**
             * Generate the jump-table itself.
             */
<span class="fc" id="L681">            final int min = 0;</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            final int max = keys.isEmpty() ? 0 : keys.size() - 1;</span>
<span class="fc" id="L683">            final TableSwitchInsnNode table = new TableSwitchInsnNode(min, max, default_case);</span>

            // Load the actual argument onto the operand-stack and then branch.
<span class="fc" id="L686">            method.instructions.add(new VarInsnNode(Opcodes.ILOAD, 1));</span>
<span class="fc" id="L687">            method.instructions.add(table);</span>

            /**
             * Generate each case in the switch-case, except the default-case.
             */
<span class="fc bfc" id="L692" title="All 2 branches covered.">            for (String element : keys)</span>
            {
                /**
                 * Get the static-type of the element.
                 */
<span class="fc" id="L697">                final IVariableType element_type = typeOfElement(element);</span>

                /**
                 * Mark the entry-point of the switch-case.
                 */
<span class="fc" id="L702">                final LabelNode label = new LabelNode();</span>
<span class="fc" id="L703">                table.labels.add(label);</span>
<span class="fc" id="L704">                method.instructions.add(label);</span>

                /**
                 * Obtain a modifiable version of the tuple.
                 * If the tuple is modifiable, then this will be the tuple itself.
                 * Otherwise, this will be a copy of the tuple.
                 */
<span class="fc" id="L711">                loadModifiableVariant(method.instructions);</span>

                /**
                 * Duplicate the object-reference, because we will need an extra one later.
                 */
<span class="fc" id="L716">                method.instructions.add(new InsnNode(Opcodes.DUP));</span>

                /**
                 * Push the value onto an argument-stack and then pop it right back off.
                 * This will convert the value to the appropriate type.
                 *
                 * The argument is an object and is the second user-defined parameter.
                 * The first parameter is the index, which is an int.
                 */
                // Load two references to the the argument-stack.
<span class="fc" id="L726">                Utils.loadArgumentStack(method.instructions);</span>
<span class="fc" id="L727">                method.instructions.add(new InsnNode(Opcodes.DUP));</span>
                // Push
<span class="fc" id="L729">                method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 2));</span>
<span class="fc" id="L730">                Utils.pushArgument(program, method.instructions, program.typesystem.utils.OBJECT);</span>
                // Pop - Peek Value
<span class="fc" id="L732">                Utils.peekArgument(program, method.instructions, element_type);</span>
                // Pop - Clear the Argument Stack
<span class="fc" id="L734">                Utils.loadArgumentStack(method.instructions);</span>
<span class="fc" id="L735">                method.instructions.add(new InsnNode(Opcodes.POP));</span>

                /**
                 * Assign the value to the element.
                 */
<span class="fc" id="L740">                method.instructions.add(new FieldInsnNode(Opcodes.PUTFIELD,</span>
<span class="fc" id="L741">                                                          Utils.internalName(type),</span>
<span class="fc" id="L742">                                                          nameOfField(element),</span>
<span class="fc" id="L743">                                                          element_type.getDescriptor()));</span>

                /**
                 * Return the modified object.
                 * This is why the object-reference was duplicated previously.
                 */
<span class="fc" id="L749">                method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>
<span class="fc" id="L750">            }</span>

            /**
             * The default-case executes the same code that executes when the tuple is empty.
             */
<span class="fc" id="L755">            method.instructions.add(default_case);</span>
        }

        /**
         * Throw an exception, if the element does not exist.
         */
<span class="fc" id="L761">        method.instructions.add(new VarInsnNode(Opcodes.ILOAD, 1));</span>
<span class="fc" id="L762">        method.instructions.add(new LdcInsnNode(keys.size()));</span>
<span class="fc" id="L763">        Utils.invoke(method.instructions,</span>
                     Opcodes.INVOKESTATIC,
                     Helpers.class,
                     void.class,
                     &quot;throwIndexOutOfBoundsException&quot;,
                     int.class,
                     int.class);

        /**
         * Add a return instruction, even though it will never actually execute.
         * This is needed, due to bytecode verification.
         */
<span class="fc" id="L775">        method.instructions.add(new InsnNode(Opcodes.ACONST_NULL));</span>
<span class="fc" id="L776">        method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>

<span class="fc" id="L778">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of the get(int) method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodGet()
    {
<span class="fc" id="L788">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L789">                                                   TypeSystemUtils.find(type.getAllVisibleMethods(),</span>
                                                                        &quot;get&quot;,
                                                                        &quot;(I)Ljava/lang/Object;&quot;));

        // Remove the abstract modifier.
<span class="fc" id="L794">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

<span class="fc" id="L796">        final LabelNode default_case = new LabelNode();</span>

        /**
         * Essentially, this will generate a switch-statement.
         * The switch-case branches based on the index that is given as an parameter to the method.
         * If a case is executed, it will do the following things.
         * First, the value of the element is loaded onto the operand-stack.
         * Second, the value will be auto-boxed, if the element is a primitive-type.
         * Third, the value will be returned from the method.
         * The default-case will be generated at the bottom of this method,.
         * because no jump-table is needed, if the tuple is empty.
         */
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (!keys.isEmpty())</span>
        {
            /**
             * Generate the jump-table itself.
             */
<span class="fc" id="L813">            final int min = 0;</span>
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            final int max = keys.isEmpty() ? 0 : keys.size() - 1;</span>
<span class="fc" id="L815">            final TableSwitchInsnNode table = new TableSwitchInsnNode(min, max, default_case);</span>

            // Load the actual argument onto the operand-stack and then branch.
<span class="fc" id="L818">            method.instructions.add(new VarInsnNode(Opcodes.ILOAD, 1));</span>
<span class="fc" id="L819">            method.instructions.add(table);</span>

            /**
             * Generate each case in the switch-case, except the default-case.
             */
<span class="fc bfc" id="L824" title="All 2 branches covered.">            for (String element : keys)</span>
            {
                /**
                 * Get the static-type of the element.
                 */
<span class="fc" id="L829">                final IVariableType element_type = typeOfElement(element);</span>


                /**
                 * Mark the entry-point of the switch-case.
                 */
<span class="fc" id="L835">                final LabelNode label = new LabelNode();</span>
<span class="fc" id="L836">                table.labels.add(label);</span>
<span class="fc" id="L837">                method.instructions.add(label);</span>

                /**
                 * Load the value of the element onto the operand-stack.
                 * This requires retrieving the value from the field it is stored in.
                 */
<span class="fc" id="L843">                method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 0)); // Load 'this'</span>
<span class="fc" id="L844">                method.instructions.add(new FieldInsnNode(Opcodes.GETFIELD,</span>
<span class="fc" id="L845">                                                          Utils.internalName(type),</span>
<span class="fc" id="L846">                                                          nameOfField(element),</span>
<span class="fc" id="L847">                                                          element_type.getDescriptor()));</span>

                /**
                 * Box the value, if needed, so it can be added to the list.
                 */
<span class="fc" id="L852">                program.typesystem.utils.autoboxToObject(method.instructions, element_type);</span>

                /**
                 * Return the result.
                 */
<span class="fc" id="L857">                method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>
<span class="fc" id="L858">            }</span>

            /**
             * The default-case executes the same code that executes when the tuple is empty.
             */
<span class="fc" id="L863">            method.instructions.add(default_case);</span>
        }

        /**
         * Throw an exception, if the element does not exist.
         */
<span class="fc" id="L869">        method.instructions.add(new VarInsnNode(Opcodes.ILOAD, 1));</span>
<span class="fc" id="L870">        method.instructions.add(new LdcInsnNode(keys.size()));</span>
<span class="fc" id="L871">        Utils.invoke(method.instructions,</span>
                     Opcodes.INVOKESTATIC,
                     Helpers.class,
                     void.class,
                     &quot;throwIndexOutOfBoundsException&quot;,
                     int.class,
                     int.class);

        /**
         * Add a return instruction, even though it will never actually execute.
         * This is needed, due to bytecode verification.
         */
<span class="fc" id="L883">        method.instructions.add(new InsnNode(Opcodes.ACONST_NULL));</span>
<span class="fc" id="L884">        method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>

<span class="fc" id="L886">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of the keys() method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodKeys()
    {
<span class="fc" id="L896">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L897">                                                   TypeSystemUtils.find(type.getAllVisibleMethods(),</span>
                                                                        &quot;keys&quot;,
                                                                        &quot;()Ljava/util/List;&quot;));

        // Remove the abstract modifier.
<span class="fc" id="L902">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        /**
         * The method simply retrieves the value in a static field and returns it.
         */
<span class="fc" id="L907">        method.instructions.add(new FieldInsnNode(Opcodes.GETSTATIC,</span>
<span class="fc" id="L908">                                                  Utils.internalName(type),</span>
                                                  &quot;KEYS&quot;,
                                                  &quot;Ljava/util/List;&quot;));

<span class="fc" id="L912">        method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>

<span class="fc" id="L914">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of the types() method.
     *
     * @return the generated method.
     */
    private MethodNode generateMethodTypes()
    {
<span class="fc" id="L924">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L925">                                                   TypeSystemUtils.find(type.getAllVisibleMethods(),</span>
                                                                        &quot;types&quot;,
                                                                        &quot;()Ljava/util/List;&quot;));

        // Remove the abstract modifier.
<span class="fc" id="L930">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        /**
         * The method simply retrieves the value in a static field and returns it.
         */
<span class="fc" id="L935">        method.instructions.add(new FieldInsnNode(Opcodes.GETSTATIC,</span>
<span class="fc" id="L936">                                                  Utils.internalName(type),</span>
                                                  &quot;TYPES&quot;,
                                                  &quot;Ljava/util/List;&quot;));

<span class="fc" id="L940">        method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>

<span class="fc" id="L942">        return method;</span>
    }

    /**
     * This method generates the bytecode representation of a setter method.
     *
     * &lt;p&gt;
     * A setter method must obtain a modifiable variant of the tuple.
     * In other words, the setter must copy the tuple, if it is immutable.
     * Then the setter must set the field in the tuple to the new value.
     * Finally, the setter must return the modified tuple.
     * Take note, the returned tuple may not be the original tuple.
     * &lt;/p&gt;
     *
     * @param element is an object that describes the element.
     * @return the generated method.
     */
    private MethodNode generateSetter(final SetterMethod element)
    {
        /**
         * Get the static-type of the element.
         */
<span class="fc" id="L964">        final IVariableType element_type = typeOfElement(element.name);</span>


<span class="fc" id="L967">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L968">                                                   TypeSystemUtils.find(type.getMethods(),</span>
                                                                        element.name,
<span class="fc" id="L970">                                                                        &quot;(&quot; + element_type.getDescriptor() + &quot;)&quot; + type.getDescriptor()));</span>

        // Remove the abstract modifier.
<span class="fc" id="L973">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        /**
         * Get a variant of the tuple which can be modified.
         * If the original tuple is mutable, then this will simply be the original tuple.
         * If the original tuple is immutable, then this will be a copy of the original.
         */
<span class="fc" id="L980">        loadModifiableVariant(method.instructions);</span>

        /**
         * Duplicate the object-reference that refers to the tuple.
         */
<span class="fc" id="L985">        method.instructions.add(new InsnNode(Opcodes.DUP));</span>


        /**
         * Load the value, which will be assigned to the field, onto the operand-stack.
         */
<span class="fc" id="L991">        method.instructions.add(Utils.selectLoadVarInsn(element_type, 1));</span>

        /**
         * Set the field that stores the value of the element.
         */
<span class="fc" id="L996">        method.instructions.add(new FieldInsnNode(Opcodes.PUTFIELD,</span>
<span class="fc" id="L997">                                                  Utils.internalName(type),</span>
<span class="fc" id="L998">                                                  nameOfField(element.name),</span>
<span class="fc" id="L999">                                                  element_type.getDescriptor()));</span>

        /**
         * Return the result.
         */
<span class="fc" id="L1004">        method.instructions.add(new InsnNode(Opcodes.ARETURN));</span>

<span class="fc" id="L1006">        return method;</span>
    }

    /**
     * This method generates bytecode that creates a copy of the record.
     *
     * &lt;p&gt;
     * This method expects that the record object is the topmost element of the operand-stack.
     * &lt;/p&gt;
     *
     * @param code is the bytecode being generated.
     */
    private void loadModifiableVariant(final InsnList code)
    {
        // Generated Bytecode:
        //
        // NEW *type*              - Create a new uninitialized object of this record-type.
        // DUP                     - Duplicate the object-reference to the uninitialized object.
        //
        // ALOAD this              - Load 'this' onto the operand-stack.
        // GETFIELD this.field[0]  - Load value in field #0 onto the operand-stack.
        //
        // ALOAD this              - Load 'this' onto the operand-stack.
        // GETFIELD this.field[1]  - Load value in field #1 onto the operand-stack.
        //
        // ALOAD this              - Load 'this' onto the operand-stack.
        // GETFIELD this.field[2]  - Load value in field #2 onto the operand-stack.
        //
        // ...
        //
        // ALOAD this              - Load 'this' onto the operand-stack.
        // GETFIELD this.field[n]  - Load value in field #n onto the operand-stack.
        //
        // INVOKESPECIAL &lt;init&gt;    - Invoke the only ctor that the uninitialized object has.
        //                         - The constructor takes the previous field values as arguments.
        //                         - Essentially, we are simply copying the 'this' object.
        //                         - However, the ctor does *not* copy the special method bindings.
        //                         - So, we still need to do that.
        //
        // NOTE                    - The uninitialized object is now initialized.
        //                         - A reference to that object is on the top of the operand-stack.
        //
        ////////////////////////////////////////////////////////////////////////////////////////////


        /**
         * Create a new uninitialized instance of the tuple.
         */
<span class="fc" id="L1054">        code.add(new TypeInsnNode(Opcodes.NEW, Utils.internalName(type)));</span>

        /**
         * Duplicate the object-reference.
         */
<span class="fc" id="L1059">        code.add(new InsnNode(Opcodes.DUP));</span>

        /**
         * Load the value of each element onto the operand-stack.
         */
<span class="fc bfc" id="L1064" title="All 2 branches covered.">        for (String element : keys)</span>
        {
            /**
             * Get the static-type of the element.
             */
<span class="fc" id="L1069">            final IVariableType element_type = typeOfElement(element);</span>

            /**
             * Load the value of the element onto the operand-stack.
             * This requires retrieving the value from the field it is stored in.
             */
<span class="fc" id="L1075">            code.add(new VarInsnNode(Opcodes.ALOAD, 0)); // Load 'this'</span>
<span class="fc" id="L1076">            code.add(new FieldInsnNode(Opcodes.GETFIELD,</span>
<span class="fc" id="L1077">                                       Utils.internalName(type),</span>
<span class="fc" id="L1078">                                       nameOfField(element),</span>
<span class="fc" id="L1079">                                       element_type.getDescriptor()));</span>
<span class="fc" id="L1080">        }</span>

        /**
         * Invoke the constructor in order to create a copy of this object.
         */
<span class="fc" id="L1085">        code.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
<span class="fc" id="L1086">                                    Utils.internalName(type),</span>
                                    &quot;&lt;init&gt;&quot;,
<span class="fc" id="L1088">                                    ctor.getDescriptor()));</span>
<span class="fc" id="L1089">    }</span>

    /**
     * This method generates the bytecode representation of a getter method.
     *
     * &lt;p&gt;
     * A getter method simply read the field that stores the element and then returns the result.
     * &lt;/p&gt;
     *
     * @param element is an object that describes the element.
     * @return the generated method.
     */
    private MethodNode generateGetter(final GetterMethod element)
    {
        /**
         * Get the static-type of the element.
         */
<span class="fc" id="L1106">        final IVariableType element_type = typeOfElement(element.name);</span>


<span class="fc" id="L1109">        final MethodNode method = Utils.bytecodeOf(module,</span>
<span class="fc" id="L1110">                                                   TypeSystemUtils.find(type.getMethods(),</span>
                                                                        element.name,
<span class="fc" id="L1112">                                                                        &quot;()&quot; + element_type.getDescriptor()));</span>

        // Remove the abstract modifier.
<span class="fc" id="L1115">        method.access = method.access &amp; (~Opcodes.ACC_ABSTRACT);</span>

        /**
         * The method simply retrieves the value in a field and returns it.
         */
<span class="fc" id="L1120">        method.instructions.add(new VarInsnNode(Opcodes.ALOAD, 0)); // Load 'this'</span>
<span class="fc" id="L1121">        method.instructions.add(new FieldInsnNode(Opcodes.GETFIELD,</span>
<span class="fc" id="L1122">                                                  Utils.internalName(type),</span>
<span class="fc" id="L1123">                                                  nameOfField(element.name),</span>
<span class="fc" id="L1124">                                                  element_type.getDescriptor()));</span>

        /**
         * Return the result.
         */
<span class="fc" id="L1129">        method.instructions.add(Utils.selectReturnInsn(element_type));</span>

<span class="fc" id="L1131">        return method;</span>
    }

    /**
     * This method retrieves the static-type of an element given the element's name.
     *
     * @param key is the name of the element.
     * @return the most-specific static-type of the element.
     */
    private IVariableType typeOfElement(final String key)
    {
<span class="fc" id="L1142">        final IVariableType result = analyzer.elements.get(key).type();</span>

<span class="fc" id="L1144">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>