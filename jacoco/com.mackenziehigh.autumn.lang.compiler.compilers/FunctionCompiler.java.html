<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionCompiler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.mackenziehigh:autumn</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.autumn.lang.compiler.compilers</a> &gt; <span class="el_source">FunctionCompiler.java</span></div><h1>FunctionCompiler.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.autumn.lang.compiler.compilers;

import autumn.lang.compiler.ast.nodes.FormalParameter;
import autumn.lang.compiler.ast.nodes.FunctionDefinition;
import autumn.lang.compiler.ast.nodes.Variable;
import autumn.lang.compiler.errors.ErrorCode;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.mackenziehigh.autumn.lang.compiler.typesystem.CustomFormalParameter;
import com.mackenziehigh.autumn.lang.compiler.typesystem.CustomMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IAnnotation;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IAnnotationType;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IFormalParameter;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IMethod;
import com.mackenziehigh.autumn.lang.compiler.typesystem.design.IVariableType;
import com.mackenziehigh.autumn.lang.compiler.utils.Utils;
import com.mackenziehigh.autumn.resources.Finished;
import java.lang.reflect.Modifier;
import java.util.List;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;

/**
 * An instance of this class controls the compilation of a function-definition.
 *
 * @author Mackenzie High
 */
@Finished(&quot;2015/01/18&quot;)
final class FunctionCompiler
        extends AbstractFunctionCompiler
        implements ICompiler
{
    /**
     * This is the Abstract-Syntax-Tree representation of the function.
     */
    public final FunctionDefinition node;

    /**
     * This is the type-system representation of the function.
     */
    public final CustomMethod type;

    /**
     * This label marks the location that recur-statements redirect execution to.
     */
<span class="fc" id="L52">    public final LabelNode recur_label = new LabelNode();</span>

    /**
     * These are the formal-parameter variables.
     */
<span class="fc" id="L57">    private final List&lt;Variable&gt; param_vars = Lists.newArrayList();</span>

    /**
     * These are the formal-parameter types.
     */
<span class="fc" id="L62">    private final List&lt;IVariableType&gt; param_types = Lists.newArrayList();</span>

    /**
     * Sole Constructor.
     *
     * @param module is the compiler of the module that this definition is part of.
     * @param node is the AST node that represents this definition.
     */
    public FunctionCompiler(final ModuleCompiler module,
                            final FunctionDefinition node)
    {
<span class="fc" id="L73">        super(module, new VariableAllocator(0));</span>

<span class="fc" id="L75">        this.node = node;</span>

<span class="fc" id="L77">        this.type = new CustomMethod(module.program.typesystem.typefactory(), false);</span>
<span class="fc" id="L78">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeDeclaration()
    {
        // Pass
<span class="fc" id="L87">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeInitialization()
    {
        /**
         * Add this function's type to the collection of functions in the module's type.
         */
<span class="fc" id="L98">        final List&lt;IMethod&gt; functions = Lists.newLinkedList(module.type.getMethods());</span>
<span class="fc" id="L99">        functions.add(type);</span>
<span class="fc" id="L100">        module.type.setMethods(functions);</span>

        /**
         * Convert the Abstract-Syntax-Tree representations of the formal-parameters
         * to their type-system representations.
         */
<span class="fc" id="L106">        final List&lt;IFormalParameter&gt; params = Lists.newArrayList();</span>
        {
<span class="fc bfc" id="L108" title="All 2 branches covered.">            for (FormalParameter p : node.getParameters().getParameters())</span>
            {
<span class="fc" id="L110">                final IVariableType param_type = module.imports.resolveVariableType(p.getType());</span>

<span class="fc" id="L112">                final CustomFormalParameter param = new CustomFormalParameter();</span>
<span class="fc" id="L113">                param.setAnnotations(ImmutableList.&lt;IAnnotation&gt;of());</span>
<span class="fc" id="L114">                param.setType(param_type);</span>
<span class="fc" id="L115">                params.add(param);</span>

<span class="fc" id="L117">                param_vars.add(p.getVariable());</span>
<span class="fc" id="L118">                param_types.add(param_type);</span>
<span class="fc" id="L119">            }</span>
        }

        /**
         * Create the type-system representation the function.
         */
<span class="fc" id="L125">        type.setOwner(module.type);</span>
<span class="fc" id="L126">        type.setAnnotations(module.anno_utils.typesOf(node.getAnnotations()));</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        type.setModifiers(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | (isAnnotationPresent(program.typesystem.utils.SYNC) ? Modifier.SYNCHRONIZED : 0));</span>
<span class="fc" id="L128">        type.setName(node.getName().getName());</span>
<span class="fc" id="L129">        type.setParameters(params);</span>
<span class="fc" id="L130">        type.setReturnType(module.imports.resolveReturnType(node.getReturnType()));</span>

        /**
         * Add a special annotation.
         */
<span class="fc" id="L135">        module.anno_utils.add(type, autumn.lang.internals.annotations.FunctionDefinition.class);</span>
<span class="fc" id="L136">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeStructureChecking()
    {
        /**
         * Check the list of annotations.
         */
<span class="fc" id="L147">        program.checker.checkAnnotations(node.getAnnotations(), type.getAnnotations());</span>

        /**
         * Some names cannot be used.
         */
<span class="fc" id="L152">        program.checker.checkName(node.getName(), &quot;instance&quot;);</span>

        /**
         * Check the signature of a infer-function.
         */
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (isAnnotationPresent(program.typesystem.utils.INFER))</span>
        {
<span class="fc" id="L159">            boolean error = false;</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (param_types.isEmpty())</span>
            {
<span class="fc" id="L163">                error = true;</span>
            }
<span class="fc bfc" id="L165" title="All 2 branches covered.">            else if (param_types.get(0).isReferenceType() == false)</span>
            {
<span class="fc" id="L167">                error = true;</span>
            }
<span class="fc bfc" id="L169" title="All 2 branches covered.">            else if (type.getReturnType().equals(param_types.get(0)) == false)</span>
            {
<span class="fc" id="L171">                error = true;</span>
            }

<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (error)</span>
            {
<span class="nc" id="L176">                program.checker.reportWrongSignatureForAnnotation(this, ErrorCode.WRONG_SIGNATURE_FOR_INFER, &quot;(T, ...) : T, where T is some reference-type&quot;);</span>
            }
        }

        /**
         * Check the signature of a start-function.
         */
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (isAnnotationPresent(program.typesystem.utils.START))</span>
        {
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (type.getNamePlusDescriptor().equals(&quot;main([Ljava/lang/String;)V&quot;) == false)</span>
            {
<span class="nc" id="L187">                program.checker.reportWrongSignatureForAnnotation(this, ErrorCode.WRONG_SIGNATURE_FOR_START, &quot;main (String[]) : void&quot;);</span>
            }
        }

        /**
         * Check the signature of a setup-function.
         */
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (isAnnotationPresent(program.typesystem.utils.SETUP))</span>
        {
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (type.getDescriptor().equals(&quot;()V&quot;) == false)</span>
            {
<span class="nc" id="L198">                program.checker.reportWrongSignatureForAnnotation(this, ErrorCode.WRONG_SIGNATURE_FOR_SETUP, &quot;() : void&quot;);</span>
            }
        }

        /**
         * Check the signature of a test-function.
         */
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (isAnnotationPresent(program.typesystem.utils.TEST))</span>
        {
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (type.getDescriptor().equals(&quot;(Lautumn/util/test/TestCase;)V&quot;) == false)</span>
            {
<span class="nc" id="L209">                program.checker.reportWrongSignatureForAnnotation(this, ErrorCode.WRONG_SIGNATURE_FOR_TEST, &quot;(TestCase) : void&quot;);</span>
            }
        }
<span class="fc" id="L212">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void performTypeUsageChecking()
    {
        /**
         * The function defines a scope for local variables.
         */
<span class="fc" id="L223">        allocator.enterScope();</span>
        {
            /**
             * Allocate the formal-parameter local variables.
             */
<span class="fc bfc" id="L228" title="All 2 branches covered.">            for (int i = 0; i &lt; type.getParameters().size(); i++)</span>
            {
<span class="fc" id="L230">                allocator.declareParameter(param_vars.get(i).getName(), param_types.get(i));</span>
            }

            /**
             * Visit and type-check the body of the function.
             */
            try
            {
<span class="fc" id="L238">                final StatementTypeChecker checker = new StatementTypeChecker(this);</span>

<span class="fc" id="L240">                node.getBody().accept(checker);</span>

                /**
                 * Type-checking of labels was deferred in order to avoid
                 * the need for another compiler pass.
                 */
<span class="fc" id="L246">                labels.check();</span>
            }
<span class="fc" id="L248">            catch (TypeCheckFailed ex)</span>
            {
                // Pass, because the error was already reported via the error-reporter.
<span class="fc" id="L251">            }</span>
        }
<span class="fc" id="L253">        allocator.exitScope();</span>

        /**
         * A function defines the widest available scope for local variables.
         * Therefore, no variable should be in-scope after the function's scope is exited.
         */
<span class="fc" id="L259">        allocator.checkExitStatus();</span>
<span class="fc" id="L260">    }</span>

    /**
     * This method generates the bytecode representation of the function.
     *
     * @return the aforedescribed bytecode.
     */
    public MethodNode build()
    {
        // Generated Bytecode:
        //
        // LABEL @RECUR
        //
        // &lt;init-variables&gt;
        // &lt;body&gt;
        // &lt;default-termination&gt;
        //
        //
        ///////////////////////////////////////////////////////////////////////////////////////////

        /**
         * Generate the bytecode, excluding the body.
         */
<span class="fc" id="L283">        final MethodNode method = Utils.bytecodeOf(module, type);</span>

        /**
         * The body of the function is simply a statement.
         * So, we will use a statement-compiler to compile the body.
         */
<span class="fc" id="L289">        final StatementCodeGenerator codegen = new StatementCodeGenerator(this);</span>

        /**
         * At runtime, execution will goto the recur-label,
         * whenever a recur-statement is executed inside the function.
         */
<span class="fc" id="L295">        method.instructions.add(recur_label);</span>

        /**
         * Generate bytecode that assigns default-values to the local-variables.
         */
<span class="fc" id="L300">        vars.initScope();</span>

        /**
         * Generate the bytecode of the body.
         */
<span class="fc" id="L305">        node.getBody().accept(codegen);</span>

        /**
         * Transfer the generated instructions into the generated method.
         */
<span class="fc bfc" id="L310" title="All 2 branches covered.">        for (AbstractInsnNode insn : instructions.toArray())</span>
        {
<span class="fc" id="L312">            method.instructions.add(insn);</span>
        }

        /**
         * Generate bytecode that throws an exception,
         * if the function unexpectedly terminates.
         */
<span class="fc" id="L319">        addDefaultMethodTermination(method);</span>

        /**
         * If any bytecode level try-catch blocks were created,
         * then add them to the generated method.
         */
<span class="fc" id="L325">        method.tryCatchBlocks = ImmutableList.copyOf(trycatches);</span>

        /**
         * Return the generated bytecode representation of the function.
         */
<span class="fc" id="L330">        return method;</span>
    }

    /**
     * This method generates the default method termination bytecode.
     *
     * &lt;p&gt;
     * If a function does not contain a return statement, then execution may reach the end
     * of the function during an invocation. The JVM requires that this special case be handled.
     * Thus, it is necessary to generate bytecode to handle this special situation.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Per the specification, a function will simply return, if the return-type is void.
     * On the other hand, the function will raise an exception, if the return-type is non-void.
     * &lt;/p&gt;
     *
     * @param is the bytecode representation of the function.
     */
    private void addDefaultMethodTermination(final MethodNode method)
    {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (isReturnTypeVoid())</span>
        {
<span class="fc" id="L353">            method.instructions.add(new InsnNode(Opcodes.RETURN));</span>
        }
        else
        {
<span class="fc" id="L357">            method.instructions.add(new TypeInsnNode(Opcodes.NEW, &quot;autumn/lang/exceptions/UnexpectedTerminationException&quot;));</span>
<span class="fc" id="L358">            method.instructions.add(new InsnNode(Opcodes.DUP));</span>
<span class="fc" id="L359">            method.instructions.add(new MethodInsnNode(Opcodes.INVOKESPECIAL,</span>
                                                       &quot;autumn/lang/exceptions/UnexpectedTerminationException&quot;,
                                                       &quot;&lt;init&gt;&quot;,
                                                       &quot;()V&quot;));
<span class="fc" id="L363">            method.instructions.add(new InsnNode(Opcodes.ATHROW));</span>
        }
<span class="fc" id="L365">    }</span>

    /**
     * This convenience function determines whether the function's return-type is void.
     *
     * @return true, iff the function returns void.
     */
    private boolean isReturnTypeVoid()
    {
<span class="fc bfc" id="L374" title="All 2 branches covered.">        return &quot;void&quot;.equals(node.getReturnType().getName().getName())</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">               &amp;&amp; node.getReturnType().getDimensions() == null</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">               &amp;&amp; node.getReturnType().getNamespace() == null;</span>
    }

    /**
     * This method determines whether a particular annotation is applied to this method.
     *
     * @param anno is the type of the annotation.
     * @return true, iff an annotation of the specified type is applied to this function.
     */
    public final boolean isAnnotationPresent(final IAnnotationType anno)
    {
<span class="fc" id="L387">        Preconditions.checkNotNull(anno);</span>

<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (IAnnotation x : type.getAnnotations())</span>
        {
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if (x.getAnnotationType().equals(anno))</span>
            {
<span class="fc" id="L393">                return true;</span>
            }
<span class="fc" id="L395">        }</span>

<span class="fc" id="L397">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>